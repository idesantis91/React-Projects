{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getMemberExpressionValuePath;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getNameOrValue = _interopRequireDefault(require(\"./getNameOrValue\"));\n\nvar _expressionTo = require(\"./expressionTo\");\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"./isReactForwardRefCall\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction resolveName(path) {\n  if (_astTypes.namedTypes.VariableDeclaration.check(path.node)) {\n    const declarations = path.get('declarations');\n\n    if (declarations.value.length && declarations.value.length !== 1) {\n      throw new TypeError('Got unsupported VariableDeclaration. VariableDeclaration must only ' + 'have a single VariableDeclarator. Got ' + declarations.value.length + ' declarations.');\n    }\n\n    const value = declarations.get(0, 'id', 'name').value;\n    return value;\n  }\n\n  if (_astTypes.namedTypes.FunctionDeclaration.check(path.node)) {\n    return path.get('id', 'name').value;\n  }\n\n  if (_astTypes.namedTypes.FunctionExpression.check(path.node) || _astTypes.namedTypes.ArrowFunctionExpression.check(path.node) || _astTypes.namedTypes.TaggedTemplateExpression.check(path.node) || _astTypes.namedTypes.CallExpression.check(path.node) || (0, _isReactForwardRefCall.default)(path)) {\n    let currentPath = path;\n\n    while (currentPath.parent) {\n      if (_astTypes.namedTypes.VariableDeclarator.check(currentPath.parent.node)) {\n        return currentPath.parent.get('id', 'name').value;\n      }\n\n      currentPath = currentPath.parent;\n    }\n\n    return;\n  }\n\n  throw new TypeError('Attempted to resolveName for an unsupported path. resolveName accepts a ' + 'VariableDeclaration, FunctionDeclaration, FunctionExpression or CallExpression. Got \"' + path.node.type + '\".');\n}\n\nfunction getRoot(node) {\n  let root = node.parent;\n\n  while (root.parent) {\n    root = root.parent;\n  }\n\n  return root;\n}\n\nfunction getMemberExpressionValuePath(variableDefinition, memberName) {\n  const localName = resolveName(variableDefinition);\n  const program = getRoot(variableDefinition);\n\n  if (!localName) {\n    // likely an immediately exported and therefore nameless/anonymous node\n    // passed in\n    return;\n  }\n\n  let result;\n  (0, _astTypes.visit)(program, {\n    visitAssignmentExpression(path) {\n      const memberPath = path.get('left');\n\n      if (!_astTypes.namedTypes.MemberExpression.check(memberPath.node)) {\n        return this.traverse(path);\n      }\n\n      if ((!memberPath.node.computed || _astTypes.namedTypes.Literal.check(memberPath.node.property)) && (0, _getNameOrValue.default)(memberPath.get('property')) === memberName && (0, _expressionTo.String)(memberPath.get('object')) === localName) {\n        result = path.get('right');\n        return false;\n      }\n\n      this.traverse(memberPath);\n    }\n\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getMemberExpressionValuePath.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","getMemberExpressionValuePath","_astTypes","_getNameOrValue","_expressionTo","_isReactForwardRefCall","resolveName","path","namedTypes","VariableDeclaration","check","node","declarations","get","length","TypeError","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","TaggedTemplateExpression","CallExpression","currentPath","parent","VariableDeclarator","type","getRoot","root","variableDefinition","memberName","localName","program","result","visit","visitAssignmentExpression","memberPath","MemberExpression","traverse","computed","Literal","property","String"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,4BAAlB;;AAEA,IAAIC,SAAS,GAAGP,OAAO,CAAC,WAAD,CAAvB;;AAEA,IAAIQ,eAAe,GAAGT,sBAAsB,CAACC,OAAO,CAAC,kBAAD,CAAR,CAA5C;;AAEA,IAAIS,aAAa,GAAGT,OAAO,CAAC,gBAAD,CAA3B;;AAEA,IAAIU,sBAAsB,GAAGX,sBAAsB,CAACC,OAAO,CAAC,yBAAD,CAAR,CAAnD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,WAAT,CAAqBC,IAArB,EAA2B;AACzB,MAAIL,SAAS,CAACM,UAAV,CAAqBC,mBAArB,CAAyCC,KAAzC,CAA+CH,IAAI,CAACI,IAApD,CAAJ,EAA+D;AAC7D,UAAMC,YAAY,GAAGL,IAAI,CAACM,GAAL,CAAS,cAAT,CAArB;;AAEA,QAAID,YAAY,CAACb,KAAb,CAAmBe,MAAnB,IAA6BF,YAAY,CAACb,KAAb,CAAmBe,MAAnB,KAA8B,CAA/D,EAAkE;AAChE,YAAM,IAAIC,SAAJ,CAAc,wEAAwE,wCAAxE,GAAmHH,YAAY,CAACb,KAAb,CAAmBe,MAAtI,GAA+I,gBAA7J,CAAN;AACD;;AAED,UAAMf,KAAK,GAAGa,YAAY,CAACC,GAAb,CAAiB,CAAjB,EAAoB,IAApB,EAA0B,MAA1B,EAAkCd,KAAhD;AACA,WAAOA,KAAP;AACD;;AAED,MAAIG,SAAS,CAACM,UAAV,CAAqBQ,mBAArB,CAAyCN,KAAzC,CAA+CH,IAAI,CAACI,IAApD,CAAJ,EAA+D;AAC7D,WAAOJ,IAAI,CAACM,GAAL,CAAS,IAAT,EAAe,MAAf,EAAuBd,KAA9B;AACD;;AAED,MAAIG,SAAS,CAACM,UAAV,CAAqBS,kBAArB,CAAwCP,KAAxC,CAA8CH,IAAI,CAACI,IAAnD,KAA4DT,SAAS,CAACM,UAAV,CAAqBU,uBAArB,CAA6CR,KAA7C,CAAmDH,IAAI,CAACI,IAAxD,CAA5D,IAA6HT,SAAS,CAACM,UAAV,CAAqBW,wBAArB,CAA8CT,KAA9C,CAAoDH,IAAI,CAACI,IAAzD,CAA7H,IAA+LT,SAAS,CAACM,UAAV,CAAqBY,cAArB,CAAoCV,KAApC,CAA0CH,IAAI,CAACI,IAA/C,CAA/L,IAAuP,CAAC,GAAGN,sBAAsB,CAACL,OAA3B,EAAoCO,IAApC,CAA3P,EAAsS;AACpS,QAAIc,WAAW,GAAGd,IAAlB;;AAEA,WAAOc,WAAW,CAACC,MAAnB,EAA2B;AACzB,UAAIpB,SAAS,CAACM,UAAV,CAAqBe,kBAArB,CAAwCb,KAAxC,CAA8CW,WAAW,CAACC,MAAZ,CAAmBX,IAAjE,CAAJ,EAA4E;AAC1E,eAAOU,WAAW,CAACC,MAAZ,CAAmBT,GAAnB,CAAuB,IAAvB,EAA6B,MAA7B,EAAqCd,KAA5C;AACD;;AAEDsB,MAAAA,WAAW,GAAGA,WAAW,CAACC,MAA1B;AACD;;AAED;AACD;;AAED,QAAM,IAAIP,SAAJ,CAAc,6EAA6E,uFAA7E,GAAuKR,IAAI,CAACI,IAAL,CAAUa,IAAjL,GAAwL,IAAtM,CAAN;AACD;;AAED,SAASC,OAAT,CAAiBd,IAAjB,EAAuB;AACrB,MAAIe,IAAI,GAAGf,IAAI,CAACW,MAAhB;;AAEA,SAAOI,IAAI,CAACJ,MAAZ,EAAoB;AAClBI,IAAAA,IAAI,GAAGA,IAAI,CAACJ,MAAZ;AACD;;AAED,SAAOI,IAAP;AACD;;AAED,SAASzB,4BAAT,CAAsC0B,kBAAtC,EAA0DC,UAA1D,EAAsE;AACpE,QAAMC,SAAS,GAAGvB,WAAW,CAACqB,kBAAD,CAA7B;AACA,QAAMG,OAAO,GAAGL,OAAO,CAACE,kBAAD,CAAvB;;AAEA,MAAI,CAACE,SAAL,EAAgB;AACd;AACA;AACA;AACD;;AAED,MAAIE,MAAJ;AACA,GAAC,GAAG7B,SAAS,CAAC8B,KAAd,EAAqBF,OAArB,EAA8B;AAC5BG,IAAAA,yBAAyB,CAAC1B,IAAD,EAAO;AAC9B,YAAM2B,UAAU,GAAG3B,IAAI,CAACM,GAAL,CAAS,MAAT,CAAnB;;AAEA,UAAI,CAACX,SAAS,CAACM,UAAV,CAAqB2B,gBAArB,CAAsCzB,KAAtC,CAA4CwB,UAAU,CAACvB,IAAvD,CAAL,EAAmE;AACjE,eAAO,KAAKyB,QAAL,CAAc7B,IAAd,CAAP;AACD;;AAED,UAAI,CAAC,CAAC2B,UAAU,CAACvB,IAAX,CAAgB0B,QAAjB,IAA6BnC,SAAS,CAACM,UAAV,CAAqB8B,OAArB,CAA6B5B,KAA7B,CAAmCwB,UAAU,CAACvB,IAAX,CAAgB4B,QAAnD,CAA9B,KAA+F,CAAC,GAAGpC,eAAe,CAACH,OAApB,EAA6BkC,UAAU,CAACrB,GAAX,CAAe,UAAf,CAA7B,MAA6De,UAA5J,IAA0K,CAAC,GAAGxB,aAAa,CAACoC,MAAlB,EAA0BN,UAAU,CAACrB,GAAX,CAAe,QAAf,CAA1B,MAAwDgB,SAAtO,EAAiP;AAC/OE,QAAAA,MAAM,GAAGxB,IAAI,CAACM,GAAL,CAAS,OAAT,CAAT;AACA,eAAO,KAAP;AACD;;AAED,WAAKuB,QAAL,CAAcF,UAAd;AACD;;AAd2B,GAA9B;AAiBA,SAAOH,MAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getMemberExpressionValuePath;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getNameOrValue = _interopRequireDefault(require(\"./getNameOrValue\"));\n\nvar _expressionTo = require(\"./expressionTo\");\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"./isReactForwardRefCall\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction resolveName(path) {\n  if (_astTypes.namedTypes.VariableDeclaration.check(path.node)) {\n    const declarations = path.get('declarations');\n\n    if (declarations.value.length && declarations.value.length !== 1) {\n      throw new TypeError('Got unsupported VariableDeclaration. VariableDeclaration must only ' + 'have a single VariableDeclarator. Got ' + declarations.value.length + ' declarations.');\n    }\n\n    const value = declarations.get(0, 'id', 'name').value;\n    return value;\n  }\n\n  if (_astTypes.namedTypes.FunctionDeclaration.check(path.node)) {\n    return path.get('id', 'name').value;\n  }\n\n  if (_astTypes.namedTypes.FunctionExpression.check(path.node) || _astTypes.namedTypes.ArrowFunctionExpression.check(path.node) || _astTypes.namedTypes.TaggedTemplateExpression.check(path.node) || _astTypes.namedTypes.CallExpression.check(path.node) || (0, _isReactForwardRefCall.default)(path)) {\n    let currentPath = path;\n\n    while (currentPath.parent) {\n      if (_astTypes.namedTypes.VariableDeclarator.check(currentPath.parent.node)) {\n        return currentPath.parent.get('id', 'name').value;\n      }\n\n      currentPath = currentPath.parent;\n    }\n\n    return;\n  }\n\n  throw new TypeError('Attempted to resolveName for an unsupported path. resolveName accepts a ' + 'VariableDeclaration, FunctionDeclaration, FunctionExpression or CallExpression. Got \"' + path.node.type + '\".');\n}\n\nfunction getRoot(node) {\n  let root = node.parent;\n\n  while (root.parent) {\n    root = root.parent;\n  }\n\n  return root;\n}\n\nfunction getMemberExpressionValuePath(variableDefinition, memberName) {\n  const localName = resolveName(variableDefinition);\n  const program = getRoot(variableDefinition);\n\n  if (!localName) {\n    // likely an immediately exported and therefore nameless/anonymous node\n    // passed in\n    return;\n  }\n\n  let result;\n  (0, _astTypes.visit)(program, {\n    visitAssignmentExpression(path) {\n      const memberPath = path.get('left');\n\n      if (!_astTypes.namedTypes.MemberExpression.check(memberPath.node)) {\n        return this.traverse(path);\n      }\n\n      if ((!memberPath.node.computed || _astTypes.namedTypes.Literal.check(memberPath.node.property)) && (0, _getNameOrValue.default)(memberPath.get('property')) === memberName && (0, _expressionTo.String)(memberPath.get('object')) === localName) {\n        result = path.get('right');\n        return false;\n      }\n\n      this.traverse(memberPath);\n    }\n\n  });\n  return result;\n}"]},"metadata":{},"sourceType":"script"}