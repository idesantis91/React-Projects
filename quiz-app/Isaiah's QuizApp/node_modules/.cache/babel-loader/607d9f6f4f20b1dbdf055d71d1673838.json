{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parse;\nexports.ERROR_MISSING_DEFINITION = void 0;\n\nvar _Documentation = _interopRequireDefault(require(\"./Documentation\"));\n\nvar _postProcessDocumentation = _interopRequireDefault(require(\"./utils/postProcessDocumentation\"));\n\nvar _babelParser = _interopRequireDefault(require(\"./babelParser\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst ERROR_MISSING_DEFINITION = 'No suitable component definition found.';\nexports.ERROR_MISSING_DEFINITION = ERROR_MISSING_DEFINITION;\n\nfunction executeHandlers(handlers, componentDefinitions, parser) {\n  return componentDefinitions.map(componentDefinition => {\n    const documentation = new _Documentation.default();\n    handlers.forEach(handler => handler(documentation, componentDefinition, parser));\n    return (0, _postProcessDocumentation.default)(documentation.toObject());\n  });\n}\n/**\n * Takes JavaScript source code and returns an object with the information\n * extract from it.\n *\n * `resolver` is a strategy to find the AST node(s) of the component\n * definition(s) inside `src`.\n * It is a function that gets passed the program AST node of\n * the source as first argument, and a reference to the parser as second argument.\n *\n * This allows you define your own strategy for finding component definitions.\n *\n * `handlers` is an array of functions which are passed a reference to the\n * component definitions (extracted by `resolver`) so that they can extract\n * information from it. They get also passed a reference to a `Documentation`\n * object to attach the information to. A reference to the parser is parsed as the\n * last argument.\n *\n * If `resolver` returns an array of component definitions, `parse` will return\n * an array of documentation objects. If `resolver` returns a single node\n * instead, `parse` will return a documentation object.\n */\n\n\nfunction parse(src, resolver, handlers, options) {\n  const parser = (0, _babelParser.default)(options);\n  const ast = parser.parse(src);\n  ast.__src = src;\n  const componentDefinitions = resolver(ast, parser);\n\n  if (Array.isArray(componentDefinitions)) {\n    if (componentDefinitions.length === 0) {\n      throw new Error(ERROR_MISSING_DEFINITION);\n    }\n\n    return executeHandlers(handlers, componentDefinitions, parser);\n  } else if (componentDefinitions) {\n    return executeHandlers(handlers, [componentDefinitions], parser)[0];\n  }\n\n  throw new Error(ERROR_MISSING_DEFINITION);\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/parse.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","parse","ERROR_MISSING_DEFINITION","_Documentation","_postProcessDocumentation","_babelParser","executeHandlers","handlers","componentDefinitions","parser","map","componentDefinition","documentation","forEach","handler","toObject","src","resolver","options","ast","__src","Array","isArray","length","Error"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,KAAlB;AACAH,OAAO,CAACI,wBAAR,GAAmC,KAAK,CAAxC;;AAEA,IAAIC,cAAc,GAAGT,sBAAsB,CAACC,OAAO,CAAC,iBAAD,CAAR,CAA3C;;AAEA,IAAIS,yBAAyB,GAAGV,sBAAsB,CAACC,OAAO,CAAC,kCAAD,CAAR,CAAtD;;AAEA,IAAIU,YAAY,GAAGX,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAzC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMO,wBAAwB,GAAG,yCAAjC;AACAJ,OAAO,CAACI,wBAAR,GAAmCA,wBAAnC;;AAEA,SAASI,eAAT,CAAyBC,QAAzB,EAAmCC,oBAAnC,EAAyDC,MAAzD,EAAiE;AAC/D,SAAOD,oBAAoB,CAACE,GAArB,CAAyBC,mBAAmB,IAAI;AACrD,UAAMC,aAAa,GAAG,IAAIT,cAAc,CAACH,OAAnB,EAAtB;AACAO,IAAAA,QAAQ,CAACM,OAAT,CAAiBC,OAAO,IAAIA,OAAO,CAACF,aAAD,EAAgBD,mBAAhB,EAAqCF,MAArC,CAAnC;AACA,WAAO,CAAC,GAAGL,yBAAyB,CAACJ,OAA9B,EAAuCY,aAAa,CAACG,QAAd,EAAvC,CAAP;AACD,GAJM,CAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASd,KAAT,CAAee,GAAf,EAAoBC,QAApB,EAA8BV,QAA9B,EAAwCW,OAAxC,EAAiD;AAC/C,QAAMT,MAAM,GAAG,CAAC,GAAGJ,YAAY,CAACL,OAAjB,EAA0BkB,OAA1B,CAAf;AACA,QAAMC,GAAG,GAAGV,MAAM,CAACR,KAAP,CAAae,GAAb,CAAZ;AACAG,EAAAA,GAAG,CAACC,KAAJ,GAAYJ,GAAZ;AACA,QAAMR,oBAAoB,GAAGS,QAAQ,CAACE,GAAD,EAAMV,MAAN,CAArC;;AAEA,MAAIY,KAAK,CAACC,OAAN,CAAcd,oBAAd,CAAJ,EAAyC;AACvC,QAAIA,oBAAoB,CAACe,MAArB,KAAgC,CAApC,EAAuC;AACrC,YAAM,IAAIC,KAAJ,CAAUtB,wBAAV,CAAN;AACD;;AAED,WAAOI,eAAe,CAACC,QAAD,EAAWC,oBAAX,EAAiCC,MAAjC,CAAtB;AACD,GAND,MAMO,IAAID,oBAAJ,EAA0B;AAC/B,WAAOF,eAAe,CAACC,QAAD,EAAW,CAACC,oBAAD,CAAX,EAAmCC,MAAnC,CAAf,CAA0D,CAA1D,CAAP;AACD;;AAED,QAAM,IAAIe,KAAJ,CAAUtB,wBAAV,CAAN;AACD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parse;\nexports.ERROR_MISSING_DEFINITION = void 0;\n\nvar _Documentation = _interopRequireDefault(require(\"./Documentation\"));\n\nvar _postProcessDocumentation = _interopRequireDefault(require(\"./utils/postProcessDocumentation\"));\n\nvar _babelParser = _interopRequireDefault(require(\"./babelParser\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst ERROR_MISSING_DEFINITION = 'No suitable component definition found.';\nexports.ERROR_MISSING_DEFINITION = ERROR_MISSING_DEFINITION;\n\nfunction executeHandlers(handlers, componentDefinitions, parser) {\n  return componentDefinitions.map(componentDefinition => {\n    const documentation = new _Documentation.default();\n    handlers.forEach(handler => handler(documentation, componentDefinition, parser));\n    return (0, _postProcessDocumentation.default)(documentation.toObject());\n  });\n}\n/**\n * Takes JavaScript source code and returns an object with the information\n * extract from it.\n *\n * `resolver` is a strategy to find the AST node(s) of the component\n * definition(s) inside `src`.\n * It is a function that gets passed the program AST node of\n * the source as first argument, and a reference to the parser as second argument.\n *\n * This allows you define your own strategy for finding component definitions.\n *\n * `handlers` is an array of functions which are passed a reference to the\n * component definitions (extracted by `resolver`) so that they can extract\n * information from it. They get also passed a reference to a `Documentation`\n * object to attach the information to. A reference to the parser is parsed as the\n * last argument.\n *\n * If `resolver` returns an array of component definitions, `parse` will return\n * an array of documentation objects. If `resolver` returns a single node\n * instead, `parse` will return a documentation object.\n */\n\n\nfunction parse(src, resolver, handlers, options) {\n  const parser = (0, _babelParser.default)(options);\n  const ast = parser.parse(src);\n  ast.__src = src;\n  const componentDefinitions = resolver(ast, parser);\n\n  if (Array.isArray(componentDefinitions)) {\n    if (componentDefinitions.length === 0) {\n      throw new Error(ERROR_MISSING_DEFINITION);\n    }\n\n    return executeHandlers(handlers, componentDefinitions, parser);\n  } else if (componentDefinitions) {\n    return executeHandlers(handlers, [componentDefinitions], parser)[0];\n  }\n\n  throw new Error(ERROR_MISSING_DEFINITION);\n}"]},"metadata":{},"sourceType":"script"}