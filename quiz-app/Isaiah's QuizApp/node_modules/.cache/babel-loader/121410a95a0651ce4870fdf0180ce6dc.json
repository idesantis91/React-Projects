{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveObjectToNameArray = resolveObjectToNameArray;\nexports.default = resolveObjectKeysToArray;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction isObjectKeysCall(node) {\n  return _astTypes.namedTypes.CallExpression.check(node) && node.arguments.length === 1 && _astTypes.namedTypes.MemberExpression.check(node.callee) && _astTypes.namedTypes.Identifier.check(node.callee.object) && node.callee.object.name === 'Object' && _astTypes.namedTypes.Identifier.check(node.callee.property) && node.callee.property.name === 'keys';\n}\n\nfunction isWhitelistedObjectProperty(prop) {\n  return _astTypes.namedTypes.Property.check(prop) && (_astTypes.namedTypes.Identifier.check(prop.key) && !prop.computed || _astTypes.namedTypes.Literal.check(prop.key)) || _astTypes.namedTypes.SpreadElement.check(prop);\n}\n\nfunction isWhiteListedObjectTypeProperty(prop) {\n  return _astTypes.namedTypes.ObjectTypeProperty.check(prop) || _astTypes.namedTypes.ObjectTypeSpreadProperty.check(prop) || _astTypes.namedTypes.TSPropertySignature.check(prop);\n} // Resolves an ObjectExpression or an ObjectTypeAnnotation\n\n\nfunction resolveObjectToNameArray(object, raw = false) {\n  if (_astTypes.namedTypes.ObjectExpression.check(object.value) && object.value.properties.every(isWhitelistedObjectProperty) || _astTypes.namedTypes.ObjectTypeAnnotation.check(object.value) && object.value.properties.every(isWhiteListedObjectTypeProperty) || _astTypes.namedTypes.TSTypeLiteral.check(object.value) && object.value.members.every(isWhiteListedObjectTypeProperty)) {\n    let values = [];\n    let error = false;\n    const properties = _astTypes.namedTypes.TSTypeLiteral.check(object.value) ? object.get('members') : object.get('properties');\n    properties.each(propPath => {\n      if (error) return;\n      const prop = propPath.value;\n\n      if (_astTypes.namedTypes.Property.check(prop) || _astTypes.namedTypes.ObjectTypeProperty.check(prop) || _astTypes.namedTypes.TSPropertySignature.check(prop)) {\n        // Key is either Identifier or Literal\n        const name = prop.key.name || (raw ? prop.key.raw : prop.key.value);\n        values.push(name);\n      } else if (_astTypes.namedTypes.SpreadElement.check(prop) || _astTypes.namedTypes.ObjectTypeSpreadProperty.check(prop)) {\n        let spreadObject = (0, _resolveToValue.default)(propPath.get('argument'));\n\n        if (_astTypes.namedTypes.GenericTypeAnnotation.check(spreadObject.value)) {\n          const typeAlias = (0, _resolveToValue.default)(spreadObject.get('id'));\n\n          if (_astTypes.namedTypes.ObjectTypeAnnotation.check(typeAlias.get('right').value)) {\n            spreadObject = (0, _resolveToValue.default)(typeAlias.get('right'));\n          }\n        }\n\n        const spreadValues = resolveObjectToNameArray(spreadObject);\n\n        if (!spreadValues) {\n          error = true;\n          return;\n        }\n\n        values = [...values, ...spreadValues];\n      }\n    });\n\n    if (!error) {\n      return values;\n    }\n  }\n\n  return null;\n}\n/**\n * Returns an ArrayExpression which contains all the keys resolved from an object\n *\n * Ignores setters in objects\n *\n * Returns null in case of\n *  unresolvable spreads\n *  computed identifier keys\n */\n\n\nfunction resolveObjectKeysToArray(path) {\n  const node = path.node;\n\n  if (isObjectKeysCall(node)) {\n    const objectExpression = (0, _resolveToValue.default)(path.get('arguments').get(0));\n    const values = resolveObjectToNameArray(objectExpression);\n\n    if (values) {\n      const nodes = values.filter((value, index, array) => array.indexOf(value) === index).map(value => _astTypes.builders.literal(value));\n      return new _astTypes.NodePath(_astTypes.builders.arrayExpression(nodes));\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/resolveObjectKeysToArray.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","resolveObjectToNameArray","default","resolveObjectKeysToArray","_astTypes","_resolveToValue","isObjectKeysCall","node","namedTypes","CallExpression","check","arguments","length","MemberExpression","callee","Identifier","object","name","property","isWhitelistedObjectProperty","prop","Property","key","computed","Literal","SpreadElement","isWhiteListedObjectTypeProperty","ObjectTypeProperty","ObjectTypeSpreadProperty","TSPropertySignature","raw","ObjectExpression","properties","every","ObjectTypeAnnotation","TSTypeLiteral","members","values","error","get","each","propPath","push","spreadObject","GenericTypeAnnotation","typeAlias","spreadValues","path","objectExpression","nodes","filter","index","array","indexOf","map","builders","literal","NodePath","arrayExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveObjectToNameArray = resolveObjectToNameArray;\nexports.default = resolveObjectKeysToArray;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction isObjectKeysCall(node) {\n  return _astTypes.namedTypes.CallExpression.check(node) && node.arguments.length === 1 && _astTypes.namedTypes.MemberExpression.check(node.callee) && _astTypes.namedTypes.Identifier.check(node.callee.object) && node.callee.object.name === 'Object' && _astTypes.namedTypes.Identifier.check(node.callee.property) && node.callee.property.name === 'keys';\n}\n\nfunction isWhitelistedObjectProperty(prop) {\n  return _astTypes.namedTypes.Property.check(prop) && (_astTypes.namedTypes.Identifier.check(prop.key) && !prop.computed || _astTypes.namedTypes.Literal.check(prop.key)) || _astTypes.namedTypes.SpreadElement.check(prop);\n}\n\nfunction isWhiteListedObjectTypeProperty(prop) {\n  return _astTypes.namedTypes.ObjectTypeProperty.check(prop) || _astTypes.namedTypes.ObjectTypeSpreadProperty.check(prop) || _astTypes.namedTypes.TSPropertySignature.check(prop);\n} // Resolves an ObjectExpression or an ObjectTypeAnnotation\n\n\nfunction resolveObjectToNameArray(object, raw = false) {\n  if (_astTypes.namedTypes.ObjectExpression.check(object.value) && object.value.properties.every(isWhitelistedObjectProperty) || _astTypes.namedTypes.ObjectTypeAnnotation.check(object.value) && object.value.properties.every(isWhiteListedObjectTypeProperty) || _astTypes.namedTypes.TSTypeLiteral.check(object.value) && object.value.members.every(isWhiteListedObjectTypeProperty)) {\n    let values = [];\n    let error = false;\n    const properties = _astTypes.namedTypes.TSTypeLiteral.check(object.value) ? object.get('members') : object.get('properties');\n    properties.each(propPath => {\n      if (error) return;\n      const prop = propPath.value;\n\n      if (_astTypes.namedTypes.Property.check(prop) || _astTypes.namedTypes.ObjectTypeProperty.check(prop) || _astTypes.namedTypes.TSPropertySignature.check(prop)) {\n        // Key is either Identifier or Literal\n        const name = prop.key.name || (raw ? prop.key.raw : prop.key.value);\n        values.push(name);\n      } else if (_astTypes.namedTypes.SpreadElement.check(prop) || _astTypes.namedTypes.ObjectTypeSpreadProperty.check(prop)) {\n        let spreadObject = (0, _resolveToValue.default)(propPath.get('argument'));\n\n        if (_astTypes.namedTypes.GenericTypeAnnotation.check(spreadObject.value)) {\n          const typeAlias = (0, _resolveToValue.default)(spreadObject.get('id'));\n\n          if (_astTypes.namedTypes.ObjectTypeAnnotation.check(typeAlias.get('right').value)) {\n            spreadObject = (0, _resolveToValue.default)(typeAlias.get('right'));\n          }\n        }\n\n        const spreadValues = resolveObjectToNameArray(spreadObject);\n\n        if (!spreadValues) {\n          error = true;\n          return;\n        }\n\n        values = [...values, ...spreadValues];\n      }\n    });\n\n    if (!error) {\n      return values;\n    }\n  }\n\n  return null;\n}\n/**\n * Returns an ArrayExpression which contains all the keys resolved from an object\n *\n * Ignores setters in objects\n *\n * Returns null in case of\n *  unresolvable spreads\n *  computed identifier keys\n */\n\n\nfunction resolveObjectKeysToArray(path) {\n  const node = path.node;\n\n  if (isObjectKeysCall(node)) {\n    const objectExpression = (0, _resolveToValue.default)(path.get('arguments').get(0));\n    const values = resolveObjectToNameArray(objectExpression);\n\n    if (values) {\n      const nodes = values.filter((value, index, array) => array.indexOf(value) === index).map(value => _astTypes.builders.literal(value));\n      return new _astTypes.NodePath(_astTypes.builders.arrayExpression(nodes));\n    }\n  }\n\n  return null;\n}"]},"metadata":{},"sourceType":"script"}