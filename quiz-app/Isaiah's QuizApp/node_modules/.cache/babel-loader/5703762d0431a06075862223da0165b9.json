{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getTSType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"../utils/getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveObjectKeysToArray = require(\"../utils/resolveObjectKeysToArray\");\n\nvar _getTypeParameters = _interopRequireDefault(require(\"../utils/getTypeParameters\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst tsTypes = {\n  TSAnyKeyword: 'any',\n  TSBooleanKeyword: 'boolean',\n  TSUnknownKeyword: 'unknown',\n  TSNeverKeyword: 'never',\n  TSNullKeyword: 'null',\n  TSUndefinedKeyword: 'undefined',\n  TSNumberKeyword: 'number',\n  TSStringKeyword: 'string',\n  TSSymbolKeyword: 'symbol',\n  TSThisType: 'this',\n  TSObjectKeyword: 'object',\n  TSVoidKeyword: 'void'\n};\nconst namedTypes = {\n  TSArrayType: handleTSArrayType,\n  TSTypeReference: handleTSTypeReference,\n  TSTypeLiteral: handleTSTypeLiteral,\n  TSInterfaceDeclaration: handleTSInterfaceDeclaration,\n  TSUnionType: handleTSUnionType,\n  TSFunctionType: handleTSFunctionType,\n  TSIntersectionType: handleTSIntersectionType,\n  TSMappedType: handleTSMappedType,\n  TSTupleType: handleTSTupleType,\n  TSTypeQuery: handleTSTypeQuery,\n  TSTypeOperator: handleTSTypeOperator,\n  TSIndexedAccessType: handleTSIndexedAccessType\n};\n\nfunction handleTSArrayType(path, typeParams) {\n  return {\n    name: 'Array',\n    elements: [getTSTypeWithResolvedTypes(path.get('elementType'), typeParams)],\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nfunction handleTSTypeReference(path, typeParams) {\n  let type;\n\n  if (_astTypes.namedTypes.TSQualifiedName.check(path.node.typeName)) {\n    const typeName = path.get('typeName');\n\n    if (typeName.node.left.name === 'React') {\n      type = {\n        name: `${typeName.node.left.name}${typeName.node.right.name}`,\n        raw: (0, _printValue.default)(typeName)\n      };\n    } else {\n      type = {\n        name: (0, _printValue.default)(typeName).replace(/<.*>$/, '')\n      };\n    }\n  } else {\n    type = {\n      name: path.node.typeName.name\n    };\n  }\n\n  const resolvedPath = typeParams && typeParams[type.name] || (0, _resolveToValue.default)(path.get('typeName'));\n\n  if (path.node.typeParameters && resolvedPath.node.typeParameters) {\n    typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), path.get('typeParameters'), typeParams);\n  }\n\n  if (typeParams && typeParams[type.name]) {\n    type = getTSTypeWithResolvedTypes(resolvedPath);\n  }\n\n  if (resolvedPath && resolvedPath.node.typeAnnotation) {\n    type = getTSTypeWithResolvedTypes(resolvedPath.get('typeAnnotation'), typeParams);\n  } else if (path.node.typeParameters) {\n    const params = path.get('typeParameters').get('params');\n    type = { ...type,\n      elements: params.map(param => getTSTypeWithResolvedTypes(param, typeParams)),\n      raw: (0, _printValue.default)(path)\n    };\n  }\n\n  return type;\n}\n\nfunction getTSTypeWithRequirements(path, typeParams) {\n  const type = getTSTypeWithResolvedTypes(path, typeParams);\n  type.required = !path.parentPath.node.optional;\n  return type;\n}\n\nfunction handleTSTypeLiteral(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: []\n    }\n  };\n  path.get('members').each(param => {\n    if (_astTypes.namedTypes.TSPropertySignature.check(param.node) || _astTypes.namedTypes.TSMethodSignature.check(param.node)) {\n      const propName = (0, _getPropertyName.default)(param);\n\n      if (!propName) {\n        return;\n      }\n\n      type.signature.properties.push({\n        key: propName,\n        value: getTSTypeWithRequirements(param.get('typeAnnotation'), typeParams)\n      });\n    } else if (_astTypes.namedTypes.TSCallSignatureDeclaration.check(param.node)) {\n      type.signature.constructor = handleTSFunctionType(param, typeParams);\n    } else if (_astTypes.namedTypes.TSIndexSignature.check(param.node)) {\n      type.signature.properties.push({\n        key: getTSTypeWithResolvedTypes(param.get('parameters').get(0).get('typeAnnotation'), typeParams),\n        value: getTSTypeWithRequirements(param.get('typeAnnotation'), typeParams)\n      });\n    }\n  });\n  return type;\n}\n\nfunction handleTSInterfaceDeclaration(path) {\n  // Interfaces are handled like references which would be documented separately,\n  // rather than inlined like type aliases.\n  return {\n    name: path.node.id.name\n  };\n}\n\nfunction handleTSUnionType(path, typeParams) {\n  return {\n    name: 'union',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getTSTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleTSIntersectionType(path, typeParams) {\n  return {\n    name: 'intersection',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getTSTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleTSMappedType(path, typeParams) {\n  const key = getTSTypeWithResolvedTypes(path.get('typeParameter').get('constraint'), typeParams);\n  key.required = !path.node.optional;\n  return {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: [{\n        key,\n        value: getTSTypeWithResolvedTypes(path.get('typeAnnotation'), typeParams)\n      }]\n    }\n  };\n}\n\nfunction handleTSFunctionType(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'function',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      arguments: [],\n      return: getTSTypeWithResolvedTypes(path.get('typeAnnotation'), typeParams)\n    }\n  };\n  path.get('parameters').each(param => {\n    const typeAnnotation = (0, _getTypeAnnotation.default)(param);\n    const arg = {\n      name: param.node.name || '',\n      type: typeAnnotation ? getTSTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined\n    };\n\n    if (param.node.name === 'this') {\n      type.signature.this = arg.type;\n      return;\n    }\n\n    if (param.node.type === 'RestElement') {\n      arg.name = param.node.argument.name;\n      arg.rest = true;\n    }\n\n    type.signature.arguments.push(arg);\n  });\n  return type;\n}\n\nfunction handleTSTupleType(path, typeParams) {\n  const type = {\n    name: 'tuple',\n    raw: (0, _printValue.default)(path),\n    elements: []\n  };\n  path.get('elementTypes').each(param => {\n    type.elements.push(getTSTypeWithResolvedTypes(param, typeParams));\n  });\n  return type;\n}\n\nfunction handleTSTypeQuery(path, typeParams) {\n  const resolvedPath = (0, _resolveToValue.default)(path.get('exprName'));\n\n  if (resolvedPath && resolvedPath.node.typeAnnotation) {\n    return getTSTypeWithResolvedTypes(resolvedPath.get('typeAnnotation'), typeParams);\n  }\n\n  return {\n    name: path.node.exprName.name\n  };\n}\n\nfunction handleTSTypeOperator(path) {\n  if (path.node.operator !== 'keyof') {\n    return null;\n  }\n\n  let value = path.get('typeAnnotation');\n\n  if (_astTypes.namedTypes.TSTypeQuery.check(value.node)) {\n    value = value.get('exprName');\n  } else if (value.node.id) {\n    value = value.get('id');\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(value);\n\n  if (resolvedPath && (_astTypes.namedTypes.ObjectExpression.check(resolvedPath.node) || _astTypes.namedTypes.TSTypeLiteral.check(resolvedPath.node))) {\n    const keys = (0, _resolveObjectKeysToArray.resolveObjectToNameArray)(resolvedPath, true);\n\n    if (keys) {\n      return {\n        name: 'union',\n        raw: (0, _printValue.default)(path),\n        elements: keys.map(key => ({\n          name: 'literal',\n          value: key\n        }))\n      };\n    }\n  }\n}\n\nfunction handleTSIndexedAccessType(path, typeParams) {\n  // eslint-disable-next-line no-undef\n  const objectType = getTSTypeWithResolvedTypes(path.get('objectType'), typeParams); // eslint-disable-next-line no-undef\n\n  const indexType = getTSTypeWithResolvedTypes(path.get('indexType'), typeParams); // We only get the signature if the objectType is a type (vs interface)\n\n  if (!objectType.signature) return {\n    name: `${objectType.name}[${indexType.value.toString()}]`,\n    raw: (0, _printValue.default)(path)\n  };\n  const resolvedType = objectType.signature.properties.find(p => {\n    // indexType.value = \"'foo'\"\n    return p.key === indexType.value.replace(/['\"]+/g, '');\n  });\n\n  if (!resolvedType) {\n    return {\n      name: 'unknown'\n    };\n  }\n\n  return {\n    name: resolvedType.value.name,\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nlet visitedTypes = {};\n\nfunction getTSTypeWithResolvedTypes(path, typeParams) {\n  if (_astTypes.namedTypes.TSTypeAnnotation.check(path.node)) {\n    path = path.get('typeAnnotation');\n  }\n\n  const node = path.node;\n  let type;\n\n  const isTypeAlias = _astTypes.namedTypes.TSTypeAliasDeclaration.check(path.parentPath.node); // When we see a typealias mark it as visited so that the next\n  // call of this function does not run into an endless loop\n\n\n  if (isTypeAlias) {\n    if (visitedTypes[path.parentPath.node.id.name] === true) {\n      // if we are currently visiting this node then just return the name\n      // as we are starting to endless loop\n      return {\n        name: path.parentPath.node.id.name\n      };\n    } else if (typeof visitedTypes[path.parentPath.node.id.name] === 'object') {\n      // if we already resolved the type simple return it\n      return visitedTypes[path.parentPath.node.id.name];\n    } // mark the type as visited\n\n\n    visitedTypes[path.parentPath.node.id.name] = true;\n  }\n\n  if (node.type in tsTypes) {\n    type = {\n      name: tsTypes[node.type]\n    };\n  } else if (_astTypes.namedTypes.TSLiteralType.check(node)) {\n    type = {\n      name: 'literal',\n      value: node.literal.raw || `${node.literal.value}`\n    };\n  } else if (node.type in namedTypes) {\n    type = namedTypes[node.type](path, typeParams);\n  }\n\n  if (!type) {\n    type = {\n      name: 'unknown'\n    };\n  }\n\n  if (isTypeAlias) {\n    // mark the type as unvisited so that further calls can resolve the type again\n    visitedTypes[path.parentPath.node.id.name] = type;\n  }\n\n  return type;\n}\n/**\n * Tries to identify the typescript type by inspecting the path for known\n * typescript type names. This method doesn't check whether the found type is actually\n * existing. It simply assumes that a match is always valid.\n *\n * If there is no match, \"unknown\" is returned.\n */\n\n\nfunction getTSType(path, typeParamMap) {\n  // Empty visited types before an after run\n  // Before: in case the detection threw and we rerun again\n  // After: cleanup memory after we are done here\n  visitedTypes = {};\n  const type = getTSTypeWithResolvedTypes(path, typeParamMap);\n  visitedTypes = {};\n  return type;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getTSType.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","getTSType","_astTypes","_getPropertyName","_printValue","_getTypeAnnotation","_resolveToValue","_resolveObjectKeysToArray","_getTypeParameters","tsTypes","TSAnyKeyword","TSBooleanKeyword","TSUnknownKeyword","TSNeverKeyword","TSNullKeyword","TSUndefinedKeyword","TSNumberKeyword","TSStringKeyword","TSSymbolKeyword","TSThisType","TSObjectKeyword","TSVoidKeyword","namedTypes","TSArrayType","handleTSArrayType","TSTypeReference","handleTSTypeReference","TSTypeLiteral","handleTSTypeLiteral","TSInterfaceDeclaration","handleTSInterfaceDeclaration","TSUnionType","handleTSUnionType","TSFunctionType","handleTSFunctionType","TSIntersectionType","handleTSIntersectionType","TSMappedType","handleTSMappedType","TSTupleType","handleTSTupleType","TSTypeQuery","handleTSTypeQuery","TSTypeOperator","handleTSTypeOperator","TSIndexedAccessType","handleTSIndexedAccessType","path","typeParams","name","elements","getTSTypeWithResolvedTypes","get","raw","type","TSQualifiedName","check","node","typeName","left","right","replace","resolvedPath","typeParameters","typeAnnotation","params","map","param","getTSTypeWithRequirements","required","parentPath","optional","signature","properties","each","TSPropertySignature","TSMethodSignature","propName","push","key","TSCallSignatureDeclaration","constructor","TSIndexSignature","id","subType","arguments","return","arg","undefined","this","argument","rest","exprName","operator","ObjectExpression","keys","resolveObjectToNameArray","objectType","indexType","toString","resolvedType","find","p","visitedTypes","TSTypeAnnotation","isTypeAlias","TSTypeAliasDeclaration","TSLiteralType","literal","typeParamMap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getTSType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"../utils/getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveObjectKeysToArray = require(\"../utils/resolveObjectKeysToArray\");\n\nvar _getTypeParameters = _interopRequireDefault(require(\"../utils/getTypeParameters\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst tsTypes = {\n  TSAnyKeyword: 'any',\n  TSBooleanKeyword: 'boolean',\n  TSUnknownKeyword: 'unknown',\n  TSNeverKeyword: 'never',\n  TSNullKeyword: 'null',\n  TSUndefinedKeyword: 'undefined',\n  TSNumberKeyword: 'number',\n  TSStringKeyword: 'string',\n  TSSymbolKeyword: 'symbol',\n  TSThisType: 'this',\n  TSObjectKeyword: 'object',\n  TSVoidKeyword: 'void'\n};\nconst namedTypes = {\n  TSArrayType: handleTSArrayType,\n  TSTypeReference: handleTSTypeReference,\n  TSTypeLiteral: handleTSTypeLiteral,\n  TSInterfaceDeclaration: handleTSInterfaceDeclaration,\n  TSUnionType: handleTSUnionType,\n  TSFunctionType: handleTSFunctionType,\n  TSIntersectionType: handleTSIntersectionType,\n  TSMappedType: handleTSMappedType,\n  TSTupleType: handleTSTupleType,\n  TSTypeQuery: handleTSTypeQuery,\n  TSTypeOperator: handleTSTypeOperator,\n  TSIndexedAccessType: handleTSIndexedAccessType\n};\n\nfunction handleTSArrayType(path, typeParams) {\n  return {\n    name: 'Array',\n    elements: [getTSTypeWithResolvedTypes(path.get('elementType'), typeParams)],\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nfunction handleTSTypeReference(path, typeParams) {\n  let type;\n\n  if (_astTypes.namedTypes.TSQualifiedName.check(path.node.typeName)) {\n    const typeName = path.get('typeName');\n\n    if (typeName.node.left.name === 'React') {\n      type = {\n        name: `${typeName.node.left.name}${typeName.node.right.name}`,\n        raw: (0, _printValue.default)(typeName)\n      };\n    } else {\n      type = {\n        name: (0, _printValue.default)(typeName).replace(/<.*>$/, '')\n      };\n    }\n  } else {\n    type = {\n      name: path.node.typeName.name\n    };\n  }\n\n  const resolvedPath = typeParams && typeParams[type.name] || (0, _resolveToValue.default)(path.get('typeName'));\n\n  if (path.node.typeParameters && resolvedPath.node.typeParameters) {\n    typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), path.get('typeParameters'), typeParams);\n  }\n\n  if (typeParams && typeParams[type.name]) {\n    type = getTSTypeWithResolvedTypes(resolvedPath);\n  }\n\n  if (resolvedPath && resolvedPath.node.typeAnnotation) {\n    type = getTSTypeWithResolvedTypes(resolvedPath.get('typeAnnotation'), typeParams);\n  } else if (path.node.typeParameters) {\n    const params = path.get('typeParameters').get('params');\n    type = { ...type,\n      elements: params.map(param => getTSTypeWithResolvedTypes(param, typeParams)),\n      raw: (0, _printValue.default)(path)\n    };\n  }\n\n  return type;\n}\n\nfunction getTSTypeWithRequirements(path, typeParams) {\n  const type = getTSTypeWithResolvedTypes(path, typeParams);\n  type.required = !path.parentPath.node.optional;\n  return type;\n}\n\nfunction handleTSTypeLiteral(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: []\n    }\n  };\n  path.get('members').each(param => {\n    if (_astTypes.namedTypes.TSPropertySignature.check(param.node) || _astTypes.namedTypes.TSMethodSignature.check(param.node)) {\n      const propName = (0, _getPropertyName.default)(param);\n\n      if (!propName) {\n        return;\n      }\n\n      type.signature.properties.push({\n        key: propName,\n        value: getTSTypeWithRequirements(param.get('typeAnnotation'), typeParams)\n      });\n    } else if (_astTypes.namedTypes.TSCallSignatureDeclaration.check(param.node)) {\n      type.signature.constructor = handleTSFunctionType(param, typeParams);\n    } else if (_astTypes.namedTypes.TSIndexSignature.check(param.node)) {\n      type.signature.properties.push({\n        key: getTSTypeWithResolvedTypes(param.get('parameters').get(0).get('typeAnnotation'), typeParams),\n        value: getTSTypeWithRequirements(param.get('typeAnnotation'), typeParams)\n      });\n    }\n  });\n  return type;\n}\n\nfunction handleTSInterfaceDeclaration(path) {\n  // Interfaces are handled like references which would be documented separately,\n  // rather than inlined like type aliases.\n  return {\n    name: path.node.id.name\n  };\n}\n\nfunction handleTSUnionType(path, typeParams) {\n  return {\n    name: 'union',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getTSTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleTSIntersectionType(path, typeParams) {\n  return {\n    name: 'intersection',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getTSTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleTSMappedType(path, typeParams) {\n  const key = getTSTypeWithResolvedTypes(path.get('typeParameter').get('constraint'), typeParams);\n  key.required = !path.node.optional;\n  return {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: [{\n        key,\n        value: getTSTypeWithResolvedTypes(path.get('typeAnnotation'), typeParams)\n      }]\n    }\n  };\n}\n\nfunction handleTSFunctionType(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'function',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      arguments: [],\n      return: getTSTypeWithResolvedTypes(path.get('typeAnnotation'), typeParams)\n    }\n  };\n  path.get('parameters').each(param => {\n    const typeAnnotation = (0, _getTypeAnnotation.default)(param);\n    const arg = {\n      name: param.node.name || '',\n      type: typeAnnotation ? getTSTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined\n    };\n\n    if (param.node.name === 'this') {\n      type.signature.this = arg.type;\n      return;\n    }\n\n    if (param.node.type === 'RestElement') {\n      arg.name = param.node.argument.name;\n      arg.rest = true;\n    }\n\n    type.signature.arguments.push(arg);\n  });\n  return type;\n}\n\nfunction handleTSTupleType(path, typeParams) {\n  const type = {\n    name: 'tuple',\n    raw: (0, _printValue.default)(path),\n    elements: []\n  };\n  path.get('elementTypes').each(param => {\n    type.elements.push(getTSTypeWithResolvedTypes(param, typeParams));\n  });\n  return type;\n}\n\nfunction handleTSTypeQuery(path, typeParams) {\n  const resolvedPath = (0, _resolveToValue.default)(path.get('exprName'));\n\n  if (resolvedPath && resolvedPath.node.typeAnnotation) {\n    return getTSTypeWithResolvedTypes(resolvedPath.get('typeAnnotation'), typeParams);\n  }\n\n  return {\n    name: path.node.exprName.name\n  };\n}\n\nfunction handleTSTypeOperator(path) {\n  if (path.node.operator !== 'keyof') {\n    return null;\n  }\n\n  let value = path.get('typeAnnotation');\n\n  if (_astTypes.namedTypes.TSTypeQuery.check(value.node)) {\n    value = value.get('exprName');\n  } else if (value.node.id) {\n    value = value.get('id');\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(value);\n\n  if (resolvedPath && (_astTypes.namedTypes.ObjectExpression.check(resolvedPath.node) || _astTypes.namedTypes.TSTypeLiteral.check(resolvedPath.node))) {\n    const keys = (0, _resolveObjectKeysToArray.resolveObjectToNameArray)(resolvedPath, true);\n\n    if (keys) {\n      return {\n        name: 'union',\n        raw: (0, _printValue.default)(path),\n        elements: keys.map(key => ({\n          name: 'literal',\n          value: key\n        }))\n      };\n    }\n  }\n}\n\nfunction handleTSIndexedAccessType(path, typeParams) {\n  // eslint-disable-next-line no-undef\n  const objectType = getTSTypeWithResolvedTypes(path.get('objectType'), typeParams); // eslint-disable-next-line no-undef\n\n  const indexType = getTSTypeWithResolvedTypes(path.get('indexType'), typeParams); // We only get the signature if the objectType is a type (vs interface)\n\n  if (!objectType.signature) return {\n    name: `${objectType.name}[${indexType.value.toString()}]`,\n    raw: (0, _printValue.default)(path)\n  };\n  const resolvedType = objectType.signature.properties.find(p => {\n    // indexType.value = \"'foo'\"\n    return p.key === indexType.value.replace(/['\"]+/g, '');\n  });\n\n  if (!resolvedType) {\n    return {\n      name: 'unknown'\n    };\n  }\n\n  return {\n    name: resolvedType.value.name,\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nlet visitedTypes = {};\n\nfunction getTSTypeWithResolvedTypes(path, typeParams) {\n  if (_astTypes.namedTypes.TSTypeAnnotation.check(path.node)) {\n    path = path.get('typeAnnotation');\n  }\n\n  const node = path.node;\n  let type;\n\n  const isTypeAlias = _astTypes.namedTypes.TSTypeAliasDeclaration.check(path.parentPath.node); // When we see a typealias mark it as visited so that the next\n  // call of this function does not run into an endless loop\n\n\n  if (isTypeAlias) {\n    if (visitedTypes[path.parentPath.node.id.name] === true) {\n      // if we are currently visiting this node then just return the name\n      // as we are starting to endless loop\n      return {\n        name: path.parentPath.node.id.name\n      };\n    } else if (typeof visitedTypes[path.parentPath.node.id.name] === 'object') {\n      // if we already resolved the type simple return it\n      return visitedTypes[path.parentPath.node.id.name];\n    } // mark the type as visited\n\n\n    visitedTypes[path.parentPath.node.id.name] = true;\n  }\n\n  if (node.type in tsTypes) {\n    type = {\n      name: tsTypes[node.type]\n    };\n  } else if (_astTypes.namedTypes.TSLiteralType.check(node)) {\n    type = {\n      name: 'literal',\n      value: node.literal.raw || `${node.literal.value}`\n    };\n  } else if (node.type in namedTypes) {\n    type = namedTypes[node.type](path, typeParams);\n  }\n\n  if (!type) {\n    type = {\n      name: 'unknown'\n    };\n  }\n\n  if (isTypeAlias) {\n    // mark the type as unvisited so that further calls can resolve the type again\n    visitedTypes[path.parentPath.node.id.name] = type;\n  }\n\n  return type;\n}\n/**\n * Tries to identify the typescript type by inspecting the path for known\n * typescript type names. This method doesn't check whether the found type is actually\n * existing. It simply assumes that a match is always valid.\n *\n * If there is no match, \"unknown\" is returned.\n */\n\n\nfunction getTSType(path, typeParamMap) {\n  // Empty visited types before an after run\n  // Before: in case the detection threw and we rerun again\n  // After: cleanup memory after we are done here\n  visitedTypes = {};\n  const type = getTSTypeWithResolvedTypes(path, typeParamMap);\n  visitedTypes = {};\n  return type;\n}"]},"metadata":{},"sourceType":"script"}