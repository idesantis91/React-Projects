{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToFlowTypeProperties = applyToFlowTypeProperties;\nexports.default = void 0;\n\nvar _getMemberValuePath = _interopRequireDefault(require(\"./getMemberValuePath\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"./getTypeAnnotation\"));\n\nvar _getTypeParameters = _interopRequireDefault(require(\"./getTypeParameters\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"./isReactComponentClass\"));\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"./isReactForwardRefCall\"));\n\nvar _resolveGenericTypeAnnotation = _interopRequireDefault(require(\"./resolveGenericTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction getStatelessPropsPath(componentDefinition) {\n  const value = (0, _resolveToValue.default)(componentDefinition);\n\n  if ((0, _isReactForwardRefCall.default)(value)) {\n    const inner = (0, _resolveToValue.default)(value.get('arguments', 0));\n    return inner.get('params', 0);\n  }\n\n  return value.get('params', 0);\n}\n/**\n * Given an React component (stateless or class) tries to find the\n * flow type for the props. If not found or not one of the supported\n * component types returns null.\n */\n\n\nvar _default = path => {\n  let typePath = null;\n\n  if ((0, _isReactComponentClass.default)(path)) {\n    const superTypes = path.get('superTypeParameters');\n\n    if (superTypes.value) {\n      const params = superTypes.get('params');\n\n      if (params.value.length === 3) {\n        typePath = params.get(1);\n      } else {\n        typePath = params.get(0);\n      }\n    } else {\n      const propsMemberPath = (0, _getMemberValuePath.default)(path, 'props');\n\n      if (!propsMemberPath) {\n        return null;\n      }\n\n      typePath = (0, _getTypeAnnotation.default)(propsMemberPath.parentPath);\n    }\n\n    return typePath;\n  }\n\n  const propsParam = getStatelessPropsPath(path);\n\n  if (propsParam) {\n    typePath = (0, _getTypeAnnotation.default)(propsParam);\n  }\n\n  return typePath;\n};\n\nexports.default = _default;\n\nfunction applyToFlowTypeProperties(documentation, path, callback, typeParams) {\n  if (path.node.properties) {\n    path.get('properties').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.members) {\n    path.get('members').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'InterfaceDeclaration') {\n    if (path.node.extends) {\n      applyExtends(documentation, path, callback, typeParams);\n    }\n\n    path.get('body', 'properties').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'TSInterfaceDeclaration') {\n    if (path.node.extends) {\n      applyExtends(documentation, path, callback, typeParams);\n    }\n\n    path.get('body', 'body').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'IntersectionTypeAnnotation' || path.node.type === 'TSIntersectionType') {\n    path.get('types').each(typesPath => applyToFlowTypeProperties(documentation, typesPath, callback, typeParams));\n  } else if (path.node.type !== 'UnionTypeAnnotation') {\n    // The react-docgen output format does not currently allow\n    // for the expression of union types\n    const typePath = (0, _resolveGenericTypeAnnotation.default)(path);\n\n    if (typePath) {\n      applyToFlowTypeProperties(documentation, typePath, callback, typeParams);\n    }\n  }\n}\n\nfunction applyExtends(documentation, path, callback, typeParams) {\n  path.get('extends').each(extendsPath => {\n    const resolvedPath = (0, _resolveGenericTypeAnnotation.default)(extendsPath);\n\n    if (resolvedPath) {\n      if (resolvedPath.node.typeParameters && extendsPath.node.typeParameters) {\n        typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), extendsPath.get('typeParameters'), typeParams);\n      }\n\n      applyToFlowTypeProperties(documentation, resolvedPath, callback, typeParams);\n    } else {\n      const id = extendsPath.node.id || extendsPath.node.typeName || extendsPath.node.expression;\n\n      if (id && id.type === 'Identifier') {\n        documentation.addComposes(id.name);\n      }\n    }\n  });\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getFlowTypeFromReactComponent.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","applyToFlowTypeProperties","default","_getMemberValuePath","_getTypeAnnotation","_getTypeParameters","_isReactComponentClass","_isReactForwardRefCall","_resolveGenericTypeAnnotation","_resolveToValue","getStatelessPropsPath","componentDefinition","inner","get","_default","path","typePath","superTypes","params","length","propsMemberPath","parentPath","propsParam","documentation","callback","typeParams","node","properties","each","propertyPath","members","type","extends","applyExtends","typesPath","extendsPath","resolvedPath","typeParameters","id","typeName","expression","addComposes","name"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToFlowTypeProperties = applyToFlowTypeProperties;\nexports.default = void 0;\n\nvar _getMemberValuePath = _interopRequireDefault(require(\"./getMemberValuePath\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"./getTypeAnnotation\"));\n\nvar _getTypeParameters = _interopRequireDefault(require(\"./getTypeParameters\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"./isReactComponentClass\"));\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"./isReactForwardRefCall\"));\n\nvar _resolveGenericTypeAnnotation = _interopRequireDefault(require(\"./resolveGenericTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction getStatelessPropsPath(componentDefinition) {\n  const value = (0, _resolveToValue.default)(componentDefinition);\n\n  if ((0, _isReactForwardRefCall.default)(value)) {\n    const inner = (0, _resolveToValue.default)(value.get('arguments', 0));\n    return inner.get('params', 0);\n  }\n\n  return value.get('params', 0);\n}\n/**\n * Given an React component (stateless or class) tries to find the\n * flow type for the props. If not found or not one of the supported\n * component types returns null.\n */\n\n\nvar _default = path => {\n  let typePath = null;\n\n  if ((0, _isReactComponentClass.default)(path)) {\n    const superTypes = path.get('superTypeParameters');\n\n    if (superTypes.value) {\n      const params = superTypes.get('params');\n\n      if (params.value.length === 3) {\n        typePath = params.get(1);\n      } else {\n        typePath = params.get(0);\n      }\n    } else {\n      const propsMemberPath = (0, _getMemberValuePath.default)(path, 'props');\n\n      if (!propsMemberPath) {\n        return null;\n      }\n\n      typePath = (0, _getTypeAnnotation.default)(propsMemberPath.parentPath);\n    }\n\n    return typePath;\n  }\n\n  const propsParam = getStatelessPropsPath(path);\n\n  if (propsParam) {\n    typePath = (0, _getTypeAnnotation.default)(propsParam);\n  }\n\n  return typePath;\n};\n\nexports.default = _default;\n\nfunction applyToFlowTypeProperties(documentation, path, callback, typeParams) {\n  if (path.node.properties) {\n    path.get('properties').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.members) {\n    path.get('members').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'InterfaceDeclaration') {\n    if (path.node.extends) {\n      applyExtends(documentation, path, callback, typeParams);\n    }\n\n    path.get('body', 'properties').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'TSInterfaceDeclaration') {\n    if (path.node.extends) {\n      applyExtends(documentation, path, callback, typeParams);\n    }\n\n    path.get('body', 'body').each(propertyPath => callback(propertyPath, typeParams));\n  } else if (path.node.type === 'IntersectionTypeAnnotation' || path.node.type === 'TSIntersectionType') {\n    path.get('types').each(typesPath => applyToFlowTypeProperties(documentation, typesPath, callback, typeParams));\n  } else if (path.node.type !== 'UnionTypeAnnotation') {\n    // The react-docgen output format does not currently allow\n    // for the expression of union types\n    const typePath = (0, _resolveGenericTypeAnnotation.default)(path);\n\n    if (typePath) {\n      applyToFlowTypeProperties(documentation, typePath, callback, typeParams);\n    }\n  }\n}\n\nfunction applyExtends(documentation, path, callback, typeParams) {\n  path.get('extends').each(extendsPath => {\n    const resolvedPath = (0, _resolveGenericTypeAnnotation.default)(extendsPath);\n\n    if (resolvedPath) {\n      if (resolvedPath.node.typeParameters && extendsPath.node.typeParameters) {\n        typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), extendsPath.get('typeParameters'), typeParams);\n      }\n\n      applyToFlowTypeProperties(documentation, resolvedPath, callback, typeParams);\n    } else {\n      const id = extendsPath.node.id || extendsPath.node.typeName || extendsPath.node.expression;\n\n      if (id && id.type === 'Identifier') {\n        documentation.addComposes(id.name);\n      }\n    }\n  });\n}"]},"metadata":{},"sourceType":"script"}