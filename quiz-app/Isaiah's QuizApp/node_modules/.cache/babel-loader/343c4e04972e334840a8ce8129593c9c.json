{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolveToValue;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getMemberExpressionRoot = _interopRequireDefault(require(\"./getMemberExpressionRoot\"));\n\nvar _getPropertyValuePath = _interopRequireDefault(require(\"./getPropertyValuePath\"));\n\nvar _expressionTo = require(\"./expressionTo\");\n\nvar _traverse = require(\"./traverse\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction buildMemberExpressionFromPattern(path) {\n  const node = path.node;\n\n  if (_astTypes.namedTypes.Property.check(node)) {\n    const objPath = buildMemberExpressionFromPattern(path.parent);\n\n    if (objPath) {\n      return new _astTypes.NodePath(_astTypes.builders.memberExpression(objPath.node, node.key, _astTypes.namedTypes.Literal.check(node.key)), objPath);\n    }\n  } else if (_astTypes.namedTypes.ObjectPattern.check(node)) {\n    return buildMemberExpressionFromPattern(path.parent);\n  } else if (_astTypes.namedTypes.VariableDeclarator.check(node)) {\n    return path.get('init');\n  }\n\n  return null;\n}\n\nfunction findScopePath(paths, path) {\n  if (paths.length < 1) {\n    return null;\n  }\n\n  let resultPath = paths[0];\n  const parentPath = resultPath.parent;\n\n  if (_astTypes.namedTypes.ImportDefaultSpecifier.check(parentPath.node) || _astTypes.namedTypes.ImportSpecifier.check(parentPath.node) || _astTypes.namedTypes.ImportNamespaceSpecifier.check(parentPath.node) || _astTypes.namedTypes.VariableDeclarator.check(parentPath.node) || _astTypes.namedTypes.TypeAlias.check(parentPath.node) || _astTypes.namedTypes.InterfaceDeclaration.check(parentPath.node) || _astTypes.namedTypes.TSTypeAliasDeclaration.check(parentPath.node) || _astTypes.namedTypes.TSInterfaceDeclaration.check(parentPath.node)) {\n    resultPath = parentPath;\n  } else if (_astTypes.namedTypes.Property.check(parentPath.node)) {\n    // must be inside a pattern\n    const memberExpressionPath = buildMemberExpressionFromPattern(parentPath);\n\n    if (memberExpressionPath) {\n      return memberExpressionPath;\n    }\n  }\n\n  if (resultPath.node !== path.node) {\n    return resolveToValue(resultPath);\n  }\n\n  return null;\n}\n/**\n * Tries to find the last value assigned to `name` in the scope created by\n * `scope`. We are not descending into any statements (blocks).\n */\n\n\nfunction findLastAssignedValue(scope, idPath) {\n  const results = [];\n  const name = idPath.node.name;\n  (0, _traverse.traverseShallow)(scope.path, {\n    visitAssignmentExpression: function (path) {\n      const node = path.node; // Skip anything that is not an assignment to a variable with the\n      // passed name.\n      // Ensure the LHS isn't the reference we're trying to resolve.\n\n      if (!_astTypes.namedTypes.Identifier.check(node.left) || node.left === idPath.node || node.left.name !== name || node.operator !== '=') {\n        return this.traverse(path);\n      } // Ensure the RHS doesn't contain the reference we're trying to resolve.\n\n\n      const candidatePath = path.get('right');\n\n      for (let p = idPath; p && p.node != null; p = p.parent) {\n        if (p.node === candidatePath.node) {\n          return this.traverse(path);\n        }\n      }\n\n      results.push(candidatePath);\n      return false;\n    }\n  });\n\n  if (results.length === 0) {\n    return null;\n  }\n\n  return resolveToValue(results.pop());\n}\n/**\n * If the path is an identifier, it is resolved in the scope chain.\n * If it is an assignment expression, it resolves to the right hand side.\n * If it is a member expression it is resolved to it's initialization value.\n *\n * Else the path itself is returned.\n */\n\n\nfunction resolveToValue(path) {\n  const node = path.node;\n\n  if (_astTypes.namedTypes.VariableDeclarator.check(node)) {\n    if (node.init) {\n      return resolveToValue(path.get('init'));\n    }\n  } else if (_astTypes.namedTypes.MemberExpression.check(node)) {\n    const resolved = resolveToValue((0, _getMemberExpressionRoot.default)(path));\n\n    if (_astTypes.namedTypes.ObjectExpression.check(resolved.node)) {\n      let propertyPath = resolved;\n\n      for (const propertyName of (0, _expressionTo.Array)(path).slice(1)) {\n        if (propertyPath && _astTypes.namedTypes.ObjectExpression.check(propertyPath.node)) {\n          propertyPath = (0, _getPropertyValuePath.default)(propertyPath, propertyName);\n        }\n\n        if (!propertyPath) {\n          return path;\n        }\n\n        propertyPath = resolveToValue(propertyPath);\n      }\n\n      return propertyPath;\n    }\n  } else if (_astTypes.namedTypes.ImportDefaultSpecifier.check(node) || _astTypes.namedTypes.ImportNamespaceSpecifier.check(node) || _astTypes.namedTypes.ImportSpecifier.check(node)) {\n    // go up two levels as first level is only the array of specifiers\n    return path.parentPath.parentPath;\n  } else if (_astTypes.namedTypes.AssignmentExpression.check(node)) {\n    if (node.operator === '=') {\n      return resolveToValue(path.get('right'));\n    }\n  } else if (_astTypes.namedTypes.TypeCastExpression.check(node) || _astTypes.namedTypes.TSAsExpression.check(node) || _astTypes.namedTypes.TSTypeAssertion.check(node)) {\n    return resolveToValue(path.get('expression'));\n  } else if (_astTypes.namedTypes.Identifier.check(node)) {\n    if ((_astTypes.namedTypes.ClassDeclaration.check(path.parentPath.node) || _astTypes.namedTypes.ClassExpression.check(path.parentPath.node) || _astTypes.namedTypes.Function.check(path.parentPath.node)) && path.parentPath.get('id') === path) {\n      return path.parentPath;\n    }\n\n    let scope = path.scope.lookup(node.name);\n    let resolvedPath;\n\n    if (scope) {\n      // The variable may be assigned a different value after initialization.\n      // We are first trying to find all assignments to the variable in the\n      // block where it is defined (i.e. we are not traversing into statements)\n      resolvedPath = findLastAssignedValue(scope, path);\n\n      if (!resolvedPath) {\n        const bindings = scope.getBindings()[node.name];\n        resolvedPath = findScopePath(bindings, path);\n      }\n    } else {\n      scope = path.scope.lookupType(node.name);\n\n      if (scope) {\n        const typesInScope = scope.getTypes()[node.name];\n        resolvedPath = findScopePath(typesInScope, path);\n      }\n    }\n\n    return resolvedPath || path;\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/resolveToValue.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","resolveToValue","_astTypes","_getMemberExpressionRoot","_getPropertyValuePath","_expressionTo","_traverse","buildMemberExpressionFromPattern","path","node","namedTypes","Property","check","objPath","parent","NodePath","builders","memberExpression","key","Literal","ObjectPattern","VariableDeclarator","get","findScopePath","paths","length","resultPath","parentPath","ImportDefaultSpecifier","ImportSpecifier","ImportNamespaceSpecifier","TypeAlias","InterfaceDeclaration","TSTypeAliasDeclaration","TSInterfaceDeclaration","memberExpressionPath","findLastAssignedValue","scope","idPath","results","name","traverseShallow","visitAssignmentExpression","Identifier","left","operator","traverse","candidatePath","p","push","pop","init","MemberExpression","resolved","ObjectExpression","propertyPath","propertyName","Array","slice","AssignmentExpression","TypeCastExpression","TSAsExpression","TSTypeAssertion","ClassDeclaration","ClassExpression","Function","lookup","resolvedPath","bindings","getBindings","lookupType","typesInScope","getTypes"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolveToValue;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getMemberExpressionRoot = _interopRequireDefault(require(\"./getMemberExpressionRoot\"));\n\nvar _getPropertyValuePath = _interopRequireDefault(require(\"./getPropertyValuePath\"));\n\nvar _expressionTo = require(\"./expressionTo\");\n\nvar _traverse = require(\"./traverse\");\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction buildMemberExpressionFromPattern(path) {\n  const node = path.node;\n\n  if (_astTypes.namedTypes.Property.check(node)) {\n    const objPath = buildMemberExpressionFromPattern(path.parent);\n\n    if (objPath) {\n      return new _astTypes.NodePath(_astTypes.builders.memberExpression(objPath.node, node.key, _astTypes.namedTypes.Literal.check(node.key)), objPath);\n    }\n  } else if (_astTypes.namedTypes.ObjectPattern.check(node)) {\n    return buildMemberExpressionFromPattern(path.parent);\n  } else if (_astTypes.namedTypes.VariableDeclarator.check(node)) {\n    return path.get('init');\n  }\n\n  return null;\n}\n\nfunction findScopePath(paths, path) {\n  if (paths.length < 1) {\n    return null;\n  }\n\n  let resultPath = paths[0];\n  const parentPath = resultPath.parent;\n\n  if (_astTypes.namedTypes.ImportDefaultSpecifier.check(parentPath.node) || _astTypes.namedTypes.ImportSpecifier.check(parentPath.node) || _astTypes.namedTypes.ImportNamespaceSpecifier.check(parentPath.node) || _astTypes.namedTypes.VariableDeclarator.check(parentPath.node) || _astTypes.namedTypes.TypeAlias.check(parentPath.node) || _astTypes.namedTypes.InterfaceDeclaration.check(parentPath.node) || _astTypes.namedTypes.TSTypeAliasDeclaration.check(parentPath.node) || _astTypes.namedTypes.TSInterfaceDeclaration.check(parentPath.node)) {\n    resultPath = parentPath;\n  } else if (_astTypes.namedTypes.Property.check(parentPath.node)) {\n    // must be inside a pattern\n    const memberExpressionPath = buildMemberExpressionFromPattern(parentPath);\n\n    if (memberExpressionPath) {\n      return memberExpressionPath;\n    }\n  }\n\n  if (resultPath.node !== path.node) {\n    return resolveToValue(resultPath);\n  }\n\n  return null;\n}\n/**\n * Tries to find the last value assigned to `name` in the scope created by\n * `scope`. We are not descending into any statements (blocks).\n */\n\n\nfunction findLastAssignedValue(scope, idPath) {\n  const results = [];\n  const name = idPath.node.name;\n  (0, _traverse.traverseShallow)(scope.path, {\n    visitAssignmentExpression: function (path) {\n      const node = path.node; // Skip anything that is not an assignment to a variable with the\n      // passed name.\n      // Ensure the LHS isn't the reference we're trying to resolve.\n\n      if (!_astTypes.namedTypes.Identifier.check(node.left) || node.left === idPath.node || node.left.name !== name || node.operator !== '=') {\n        return this.traverse(path);\n      } // Ensure the RHS doesn't contain the reference we're trying to resolve.\n\n\n      const candidatePath = path.get('right');\n\n      for (let p = idPath; p && p.node != null; p = p.parent) {\n        if (p.node === candidatePath.node) {\n          return this.traverse(path);\n        }\n      }\n\n      results.push(candidatePath);\n      return false;\n    }\n  });\n\n  if (results.length === 0) {\n    return null;\n  }\n\n  return resolveToValue(results.pop());\n}\n/**\n * If the path is an identifier, it is resolved in the scope chain.\n * If it is an assignment expression, it resolves to the right hand side.\n * If it is a member expression it is resolved to it's initialization value.\n *\n * Else the path itself is returned.\n */\n\n\nfunction resolveToValue(path) {\n  const node = path.node;\n\n  if (_astTypes.namedTypes.VariableDeclarator.check(node)) {\n    if (node.init) {\n      return resolveToValue(path.get('init'));\n    }\n  } else if (_astTypes.namedTypes.MemberExpression.check(node)) {\n    const resolved = resolveToValue((0, _getMemberExpressionRoot.default)(path));\n\n    if (_astTypes.namedTypes.ObjectExpression.check(resolved.node)) {\n      let propertyPath = resolved;\n\n      for (const propertyName of (0, _expressionTo.Array)(path).slice(1)) {\n        if (propertyPath && _astTypes.namedTypes.ObjectExpression.check(propertyPath.node)) {\n          propertyPath = (0, _getPropertyValuePath.default)(propertyPath, propertyName);\n        }\n\n        if (!propertyPath) {\n          return path;\n        }\n\n        propertyPath = resolveToValue(propertyPath);\n      }\n\n      return propertyPath;\n    }\n  } else if (_astTypes.namedTypes.ImportDefaultSpecifier.check(node) || _astTypes.namedTypes.ImportNamespaceSpecifier.check(node) || _astTypes.namedTypes.ImportSpecifier.check(node)) {\n    // go up two levels as first level is only the array of specifiers\n    return path.parentPath.parentPath;\n  } else if (_astTypes.namedTypes.AssignmentExpression.check(node)) {\n    if (node.operator === '=') {\n      return resolveToValue(path.get('right'));\n    }\n  } else if (_astTypes.namedTypes.TypeCastExpression.check(node) || _astTypes.namedTypes.TSAsExpression.check(node) || _astTypes.namedTypes.TSTypeAssertion.check(node)) {\n    return resolveToValue(path.get('expression'));\n  } else if (_astTypes.namedTypes.Identifier.check(node)) {\n    if ((_astTypes.namedTypes.ClassDeclaration.check(path.parentPath.node) || _astTypes.namedTypes.ClassExpression.check(path.parentPath.node) || _astTypes.namedTypes.Function.check(path.parentPath.node)) && path.parentPath.get('id') === path) {\n      return path.parentPath;\n    }\n\n    let scope = path.scope.lookup(node.name);\n    let resolvedPath;\n\n    if (scope) {\n      // The variable may be assigned a different value after initialization.\n      // We are first trying to find all assignments to the variable in the\n      // block where it is defined (i.e. we are not traversing into statements)\n      resolvedPath = findLastAssignedValue(scope, path);\n\n      if (!resolvedPath) {\n        const bindings = scope.getBindings()[node.name];\n        resolvedPath = findScopePath(bindings, path);\n      }\n    } else {\n      scope = path.scope.lookupType(node.name);\n\n      if (scope) {\n        const typesInScope = scope.getTypes()[node.name];\n        resolvedPath = findScopePath(typesInScope, path);\n      }\n    }\n\n    return resolvedPath || path;\n  }\n\n  return path;\n}"]},"metadata":{},"sourceType":"script"}