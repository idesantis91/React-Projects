{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isStatelessComponent;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyValuePath = _interopRequireDefault(require(\"./getPropertyValuePath\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"./isReactComponentClass\"));\n\nvar _isReactCreateClassCall = _interopRequireDefault(require(\"./isReactCreateClassCall\"));\n\nvar _isReactCreateElementCall = _interopRequireDefault(require(\"./isReactCreateElementCall\"));\n\nvar _isReactCloneElementCall = _interopRequireDefault(require(\"./isReactCloneElementCall\"));\n\nvar _isReactChildrenElementCall = _interopRequireDefault(require(\"./isReactChildrenElementCall\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst validPossibleStatelessComponentTypes = ['Property', 'FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'];\n\nfunction isJSXElementOrReactCall(path) {\n  return path.node.type === 'JSXElement' || path.node.type === 'JSXFragment' || path.node.type === 'CallExpression' && (0, _isReactCreateElementCall.default)(path) || path.node.type === 'CallExpression' && (0, _isReactCloneElementCall.default)(path) || path.node.type === 'CallExpression' && (0, _isReactChildrenElementCall.default)(path);\n}\n\nfunction resolvesToJSXElementOrReactCall(path, seen) {\n  // avoid returns with recursive function calls\n  if (seen.has(path)) {\n    return false;\n  }\n\n  seen.add(path); // Is the path is already a JSX element or a call to one of the React.* functions\n\n  if (isJSXElementOrReactCall(path)) {\n    return true;\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(path); // If the path points to a conditional expression, then we need to look only at\n  // the two possible paths\n\n  if (resolvedPath.node.type === 'ConditionalExpression') {\n    return resolvesToJSXElementOrReactCall(resolvedPath.get('consequent'), seen) || resolvesToJSXElementOrReactCall(resolvedPath.get('alternate'), seen);\n  } // If the path points to a logical expression (AND, OR, ...), then we need to look only at\n  // the two possible paths\n\n\n  if (resolvedPath.node.type === 'LogicalExpression') {\n    return resolvesToJSXElementOrReactCall(resolvedPath.get('left'), seen) || resolvesToJSXElementOrReactCall(resolvedPath.get('right'), seen);\n  } // Is the resolved path is already a JSX element or a call to one of the React.* functions\n  // Only do this if the resolvedPath actually resolved something as otherwise we did this check already\n\n\n  if (resolvedPath !== path && isJSXElementOrReactCall(resolvedPath)) {\n    return true;\n  } // If we have a call expression, lets try to follow it\n\n\n  if (resolvedPath.node.type === 'CallExpression') {\n    let calleeValue = (0, _resolveToValue.default)(resolvedPath.get('callee'));\n\n    if (returnsJSXElementOrReactCall(calleeValue, seen)) {\n      return true;\n    }\n\n    let resolvedValue;\n    const namesToResolve = [calleeValue.get('property')];\n\n    if (calleeValue.node.type === 'MemberExpression') {\n      if (calleeValue.get('object').node.type === 'Identifier') {\n        resolvedValue = (0, _resolveToValue.default)(calleeValue.get('object'));\n      } else if (_astTypes.namedTypes.MemberExpression.check(calleeValue.node)) {\n        do {\n          calleeValue = calleeValue.get('object');\n          namesToResolve.unshift(calleeValue.get('property'));\n        } while (_astTypes.namedTypes.MemberExpression.check(calleeValue.node));\n\n        resolvedValue = (0, _resolveToValue.default)(calleeValue.get('object'));\n      }\n    }\n\n    if (resolvedValue && _astTypes.namedTypes.ObjectExpression.check(resolvedValue.node)) {\n      const resolvedMemberExpression = namesToResolve.reduce((result, nodePath) => {\n        if (!nodePath) {\n          return result;\n        }\n\n        if (result) {\n          result = (0, _getPropertyValuePath.default)(result, nodePath.node.name);\n\n          if (result && _astTypes.namedTypes.Identifier.check(result.node)) {\n            return (0, _resolveToValue.default)(result);\n          }\n        }\n\n        return result;\n      }, resolvedValue);\n\n      if (!resolvedMemberExpression || returnsJSXElementOrReactCall(resolvedMemberExpression, seen)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction returnsJSXElementOrReactCall(path, seen = new WeakSet()) {\n  let visited = false; // early exit for ArrowFunctionExpressions\n\n  if (path.node.type === 'ArrowFunctionExpression' && path.get('body').node.type !== 'BlockStatement' && resolvesToJSXElementOrReactCall(path.get('body'), seen)) {\n    return true;\n  }\n\n  let scope = path.scope; // If we get a property we want the function scope it holds and not its outer scope\n\n  if (path.node.type === 'Property') {\n    scope = path.get('value').scope;\n  }\n\n  (0, _astTypes.visit)(path, {\n    visitReturnStatement(returnPath) {\n      // Only check return statements which are part of the checked function scope\n      if (returnPath.scope !== scope) return false;\n\n      if (resolvesToJSXElementOrReactCall(returnPath.get('argument'), seen)) {\n        visited = true;\n        return false;\n      }\n\n      this.traverse(returnPath);\n    }\n\n  });\n  return visited;\n}\n/**\n * Returns `true` if the path represents a function which returns a JSXElement\n */\n\n\nfunction isStatelessComponent(path) {\n  const node = path.node;\n\n  if (validPossibleStatelessComponentTypes.indexOf(node.type) === -1) {\n    return false;\n  }\n\n  if (node.type === 'Property') {\n    if ((0, _isReactCreateClassCall.default)(path.parent) || (0, _isReactComponentClass.default)(path.parent)) {\n      return false;\n    }\n  }\n\n  if (returnsJSXElementOrReactCall(path)) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/isStatelessComponent.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","isStatelessComponent","_astTypes","_getPropertyValuePath","_isReactComponentClass","_isReactCreateClassCall","_isReactCreateElementCall","_isReactCloneElementCall","_isReactChildrenElementCall","_resolveToValue","validPossibleStatelessComponentTypes","isJSXElementOrReactCall","path","node","type","resolvesToJSXElementOrReactCall","seen","has","add","resolvedPath","get","calleeValue","returnsJSXElementOrReactCall","resolvedValue","namesToResolve","namedTypes","MemberExpression","check","unshift","ObjectExpression","resolvedMemberExpression","reduce","result","nodePath","name","Identifier","WeakSet","visited","scope","visit","visitReturnStatement","returnPath","traverse","indexOf","parent"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isStatelessComponent;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyValuePath = _interopRequireDefault(require(\"./getPropertyValuePath\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"./isReactComponentClass\"));\n\nvar _isReactCreateClassCall = _interopRequireDefault(require(\"./isReactCreateClassCall\"));\n\nvar _isReactCreateElementCall = _interopRequireDefault(require(\"./isReactCreateElementCall\"));\n\nvar _isReactCloneElementCall = _interopRequireDefault(require(\"./isReactCloneElementCall\"));\n\nvar _isReactChildrenElementCall = _interopRequireDefault(require(\"./isReactChildrenElementCall\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst validPossibleStatelessComponentTypes = ['Property', 'FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'];\n\nfunction isJSXElementOrReactCall(path) {\n  return path.node.type === 'JSXElement' || path.node.type === 'JSXFragment' || path.node.type === 'CallExpression' && (0, _isReactCreateElementCall.default)(path) || path.node.type === 'CallExpression' && (0, _isReactCloneElementCall.default)(path) || path.node.type === 'CallExpression' && (0, _isReactChildrenElementCall.default)(path);\n}\n\nfunction resolvesToJSXElementOrReactCall(path, seen) {\n  // avoid returns with recursive function calls\n  if (seen.has(path)) {\n    return false;\n  }\n\n  seen.add(path); // Is the path is already a JSX element or a call to one of the React.* functions\n\n  if (isJSXElementOrReactCall(path)) {\n    return true;\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(path); // If the path points to a conditional expression, then we need to look only at\n  // the two possible paths\n\n  if (resolvedPath.node.type === 'ConditionalExpression') {\n    return resolvesToJSXElementOrReactCall(resolvedPath.get('consequent'), seen) || resolvesToJSXElementOrReactCall(resolvedPath.get('alternate'), seen);\n  } // If the path points to a logical expression (AND, OR, ...), then we need to look only at\n  // the two possible paths\n\n\n  if (resolvedPath.node.type === 'LogicalExpression') {\n    return resolvesToJSXElementOrReactCall(resolvedPath.get('left'), seen) || resolvesToJSXElementOrReactCall(resolvedPath.get('right'), seen);\n  } // Is the resolved path is already a JSX element or a call to one of the React.* functions\n  // Only do this if the resolvedPath actually resolved something as otherwise we did this check already\n\n\n  if (resolvedPath !== path && isJSXElementOrReactCall(resolvedPath)) {\n    return true;\n  } // If we have a call expression, lets try to follow it\n\n\n  if (resolvedPath.node.type === 'CallExpression') {\n    let calleeValue = (0, _resolveToValue.default)(resolvedPath.get('callee'));\n\n    if (returnsJSXElementOrReactCall(calleeValue, seen)) {\n      return true;\n    }\n\n    let resolvedValue;\n    const namesToResolve = [calleeValue.get('property')];\n\n    if (calleeValue.node.type === 'MemberExpression') {\n      if (calleeValue.get('object').node.type === 'Identifier') {\n        resolvedValue = (0, _resolveToValue.default)(calleeValue.get('object'));\n      } else if (_astTypes.namedTypes.MemberExpression.check(calleeValue.node)) {\n        do {\n          calleeValue = calleeValue.get('object');\n          namesToResolve.unshift(calleeValue.get('property'));\n        } while (_astTypes.namedTypes.MemberExpression.check(calleeValue.node));\n\n        resolvedValue = (0, _resolveToValue.default)(calleeValue.get('object'));\n      }\n    }\n\n    if (resolvedValue && _astTypes.namedTypes.ObjectExpression.check(resolvedValue.node)) {\n      const resolvedMemberExpression = namesToResolve.reduce((result, nodePath) => {\n        if (!nodePath) {\n          return result;\n        }\n\n        if (result) {\n          result = (0, _getPropertyValuePath.default)(result, nodePath.node.name);\n\n          if (result && _astTypes.namedTypes.Identifier.check(result.node)) {\n            return (0, _resolveToValue.default)(result);\n          }\n        }\n\n        return result;\n      }, resolvedValue);\n\n      if (!resolvedMemberExpression || returnsJSXElementOrReactCall(resolvedMemberExpression, seen)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction returnsJSXElementOrReactCall(path, seen = new WeakSet()) {\n  let visited = false; // early exit for ArrowFunctionExpressions\n\n  if (path.node.type === 'ArrowFunctionExpression' && path.get('body').node.type !== 'BlockStatement' && resolvesToJSXElementOrReactCall(path.get('body'), seen)) {\n    return true;\n  }\n\n  let scope = path.scope; // If we get a property we want the function scope it holds and not its outer scope\n\n  if (path.node.type === 'Property') {\n    scope = path.get('value').scope;\n  }\n\n  (0, _astTypes.visit)(path, {\n    visitReturnStatement(returnPath) {\n      // Only check return statements which are part of the checked function scope\n      if (returnPath.scope !== scope) return false;\n\n      if (resolvesToJSXElementOrReactCall(returnPath.get('argument'), seen)) {\n        visited = true;\n        return false;\n      }\n\n      this.traverse(returnPath);\n    }\n\n  });\n  return visited;\n}\n/**\n * Returns `true` if the path represents a function which returns a JSXElement\n */\n\n\nfunction isStatelessComponent(path) {\n  const node = path.node;\n\n  if (validPossibleStatelessComponentTypes.indexOf(node.type) === -1) {\n    return false;\n  }\n\n  if (node.type === 'Property') {\n    if ((0, _isReactCreateClassCall.default)(path.parent) || (0, _isReactComponentClass.default)(path.parent)) {\n      return false;\n    }\n  }\n\n  if (returnsJSXElementOrReactCall(path)) {\n    return true;\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}