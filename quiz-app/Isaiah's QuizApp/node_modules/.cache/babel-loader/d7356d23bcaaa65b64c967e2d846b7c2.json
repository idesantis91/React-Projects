{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getMethodDocumentation;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _docblock = require(\"./docblock\");\n\nvar _getFlowType = _interopRequireDefault(require(\"./getFlowType\"));\n\nvar _getTSType = _interopRequireDefault(require(\"./getTSType\"));\n\nvar _getParameterName = _interopRequireDefault(require(\"./getParameterName\"));\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"./getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction getMethodFunctionExpression(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return (0, _resolveToValue.default)(methodPath.get('right'));\n  } // Otherwise this is a method/property node\n\n\n  return methodPath.get('value');\n}\n\nfunction getMethodParamsDoc(methodPath) {\n  const params = [];\n  const functionExpression = getMethodFunctionExpression(methodPath); // Extract param flow types.\n\n  functionExpression.get('params').each(paramPath => {\n    let type = null;\n    const typePath = (0, _getTypeAnnotation.default)(paramPath);\n\n    if (typePath && _astTypes.namedTypes.Flow.check(typePath.node)) {\n      type = (0, _getFlowType.default)(typePath);\n\n      if (_astTypes.namedTypes.GenericTypeAnnotation.check(typePath.node)) {\n        type.alias = typePath.node.id.name;\n      }\n    } else if (typePath) {\n      type = (0, _getTSType.default)(typePath);\n\n      if (_astTypes.namedTypes.TSTypeReference.check(typePath.node)) {\n        type.alias = typePath.node.typeName.name;\n      }\n    }\n\n    const param = {\n      name: (0, _getParameterName.default)(paramPath),\n      optional: paramPath.node.optional,\n      type\n    };\n    params.push(param);\n  });\n  return params;\n} // Extract flow return type.\n\n\nfunction getMethodReturnDoc(methodPath) {\n  const functionExpression = getMethodFunctionExpression(methodPath);\n\n  if (functionExpression.node.returnType) {\n    const returnType = (0, _getTypeAnnotation.default)(functionExpression.get('returnType'));\n\n    if (returnType && _astTypes.namedTypes.Flow.check(returnType.node)) {\n      return {\n        type: (0, _getFlowType.default)(returnType)\n      };\n    } else if (returnType) {\n      return {\n        type: (0, _getTSType.default)(returnType)\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getMethodModifiers(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return ['static'];\n  } // Otherwise this is a method/property node\n\n\n  const modifiers = [];\n\n  if (methodPath.node.static) {\n    modifiers.push('static');\n  }\n\n  if (methodPath.node.kind === 'get' || methodPath.node.kind === 'set') {\n    modifiers.push(methodPath.node.kind);\n  }\n\n  const functionExpression = methodPath.get('value').node;\n\n  if (functionExpression.generator) {\n    modifiers.push('generator');\n  }\n\n  if (functionExpression.async) {\n    modifiers.push('async');\n  }\n\n  return modifiers;\n}\n\nfunction getMethodName(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node) && _astTypes.namedTypes.MemberExpression.check(methodPath.node.left)) {\n    const left = methodPath.node.left;\n    const property = left.property;\n\n    if (!left.computed) {\n      return property.name;\n    }\n\n    if (_astTypes.namedTypes.Literal.check(property)) {\n      return String(property.value);\n    }\n\n    return null;\n  }\n\n  return (0, _getPropertyName.default)(methodPath);\n}\n\nfunction getMethodAccessibility(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return null;\n  } // Otherwise this is a method/property node\n\n\n  return methodPath.node.accessibility;\n}\n\nfunction getMethodDocblock(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    let path = methodPath;\n\n    do {\n      path = path.parent;\n    } while (path && !_astTypes.namedTypes.ExpressionStatement.check(path.node));\n\n    if (path) {\n      return (0, _docblock.getDocblock)(path);\n    }\n\n    return null;\n  } // Otherwise this is a method/property node\n\n\n  return (0, _docblock.getDocblock)(methodPath);\n} // Gets the documentation object for a component method.\n// Component methods may be represented as class/object method/property nodes\n// or as assignment expresions of the form `Component.foo = function() {}`\n\n\nfunction getMethodDocumentation(methodPath) {\n  if (getMethodAccessibility(methodPath) === 'private') {\n    return null;\n  }\n\n  const name = getMethodName(methodPath);\n  if (!name) return null;\n  return {\n    name,\n    docblock: getMethodDocblock(methodPath),\n    modifiers: getMethodModifiers(methodPath),\n    params: getMethodParamsDoc(methodPath),\n    returns: getMethodReturnDoc(methodPath)\n  };\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getMethodDocumentation.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","getMethodDocumentation","_astTypes","_docblock","_getFlowType","_getTSType","_getParameterName","_getPropertyName","_getTypeAnnotation","_resolveToValue","getMethodFunctionExpression","methodPath","namedTypes","AssignmentExpression","check","node","get","getMethodParamsDoc","params","functionExpression","each","paramPath","type","typePath","Flow","GenericTypeAnnotation","alias","id","name","TSTypeReference","typeName","param","optional","push","getMethodReturnDoc","returnType","getMethodModifiers","modifiers","static","kind","generator","async","getMethodName","MemberExpression","left","property","computed","Literal","String","getMethodAccessibility","accessibility","getMethodDocblock","path","parent","ExpressionStatement","getDocblock","docblock","returns"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getMethodDocumentation;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _docblock = require(\"./docblock\");\n\nvar _getFlowType = _interopRequireDefault(require(\"./getFlowType\"));\n\nvar _getTSType = _interopRequireDefault(require(\"./getTSType\"));\n\nvar _getParameterName = _interopRequireDefault(require(\"./getParameterName\"));\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"./getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction getMethodFunctionExpression(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return (0, _resolveToValue.default)(methodPath.get('right'));\n  } // Otherwise this is a method/property node\n\n\n  return methodPath.get('value');\n}\n\nfunction getMethodParamsDoc(methodPath) {\n  const params = [];\n  const functionExpression = getMethodFunctionExpression(methodPath); // Extract param flow types.\n\n  functionExpression.get('params').each(paramPath => {\n    let type = null;\n    const typePath = (0, _getTypeAnnotation.default)(paramPath);\n\n    if (typePath && _astTypes.namedTypes.Flow.check(typePath.node)) {\n      type = (0, _getFlowType.default)(typePath);\n\n      if (_astTypes.namedTypes.GenericTypeAnnotation.check(typePath.node)) {\n        type.alias = typePath.node.id.name;\n      }\n    } else if (typePath) {\n      type = (0, _getTSType.default)(typePath);\n\n      if (_astTypes.namedTypes.TSTypeReference.check(typePath.node)) {\n        type.alias = typePath.node.typeName.name;\n      }\n    }\n\n    const param = {\n      name: (0, _getParameterName.default)(paramPath),\n      optional: paramPath.node.optional,\n      type\n    };\n    params.push(param);\n  });\n  return params;\n} // Extract flow return type.\n\n\nfunction getMethodReturnDoc(methodPath) {\n  const functionExpression = getMethodFunctionExpression(methodPath);\n\n  if (functionExpression.node.returnType) {\n    const returnType = (0, _getTypeAnnotation.default)(functionExpression.get('returnType'));\n\n    if (returnType && _astTypes.namedTypes.Flow.check(returnType.node)) {\n      return {\n        type: (0, _getFlowType.default)(returnType)\n      };\n    } else if (returnType) {\n      return {\n        type: (0, _getTSType.default)(returnType)\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction getMethodModifiers(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return ['static'];\n  } // Otherwise this is a method/property node\n\n\n  const modifiers = [];\n\n  if (methodPath.node.static) {\n    modifiers.push('static');\n  }\n\n  if (methodPath.node.kind === 'get' || methodPath.node.kind === 'set') {\n    modifiers.push(methodPath.node.kind);\n  }\n\n  const functionExpression = methodPath.get('value').node;\n\n  if (functionExpression.generator) {\n    modifiers.push('generator');\n  }\n\n  if (functionExpression.async) {\n    modifiers.push('async');\n  }\n\n  return modifiers;\n}\n\nfunction getMethodName(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node) && _astTypes.namedTypes.MemberExpression.check(methodPath.node.left)) {\n    const left = methodPath.node.left;\n    const property = left.property;\n\n    if (!left.computed) {\n      return property.name;\n    }\n\n    if (_astTypes.namedTypes.Literal.check(property)) {\n      return String(property.value);\n    }\n\n    return null;\n  }\n\n  return (0, _getPropertyName.default)(methodPath);\n}\n\nfunction getMethodAccessibility(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    return null;\n  } // Otherwise this is a method/property node\n\n\n  return methodPath.node.accessibility;\n}\n\nfunction getMethodDocblock(methodPath) {\n  if (_astTypes.namedTypes.AssignmentExpression.check(methodPath.node)) {\n    let path = methodPath;\n\n    do {\n      path = path.parent;\n    } while (path && !_astTypes.namedTypes.ExpressionStatement.check(path.node));\n\n    if (path) {\n      return (0, _docblock.getDocblock)(path);\n    }\n\n    return null;\n  } // Otherwise this is a method/property node\n\n\n  return (0, _docblock.getDocblock)(methodPath);\n} // Gets the documentation object for a component method.\n// Component methods may be represented as class/object method/property nodes\n// or as assignment expresions of the form `Component.foo = function() {}`\n\n\nfunction getMethodDocumentation(methodPath) {\n  if (getMethodAccessibility(methodPath) === 'private') {\n    return null;\n  }\n\n  const name = getMethodName(methodPath);\n  if (!name) return null;\n  return {\n    name,\n    docblock: getMethodDocblock(methodPath),\n    modifiers: getMethodModifiers(methodPath),\n    params: getMethodParamsDoc(methodPath),\n    returns: getMethodReturnDoc(methodPath)\n  };\n}"]},"metadata":{},"sourceType":"script"}