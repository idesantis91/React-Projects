{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getFlowType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"../utils/getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveObjectKeysToArray = require(\"../utils/resolveObjectKeysToArray\");\n\nvar _getTypeParameters = _interopRequireDefault(require(\"../utils/getTypeParameters\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nconst flowTypes = {\n  AnyTypeAnnotation: 'any',\n  BooleanTypeAnnotation: 'boolean',\n  MixedTypeAnnotation: 'mixed',\n  NullLiteralTypeAnnotation: 'null',\n  NumberTypeAnnotation: 'number',\n  StringTypeAnnotation: 'string',\n  VoidTypeAnnotation: 'void',\n  EmptyTypeAnnotation: 'empty'\n};\nconst flowLiteralTypes = {\n  BooleanLiteralTypeAnnotation: 1,\n  NumberLiteralTypeAnnotation: 1,\n  StringLiteralTypeAnnotation: 1\n};\nconst namedTypes = {\n  ArrayTypeAnnotation: handleArrayTypeAnnotation,\n  GenericTypeAnnotation: handleGenericTypeAnnotation,\n  ObjectTypeAnnotation: handleObjectTypeAnnotation,\n  InterfaceDeclaration: handleInterfaceDeclaration,\n  UnionTypeAnnotation: handleUnionTypeAnnotation,\n  NullableTypeAnnotation: handleNullableTypeAnnotation,\n  FunctionTypeAnnotation: handleFunctionTypeAnnotation,\n  IntersectionTypeAnnotation: handleIntersectionTypeAnnotation,\n  TupleTypeAnnotation: handleTupleTypeAnnotation,\n  TypeofTypeAnnotation: handleTypeofTypeAnnotation\n};\n\nfunction getFlowTypeWithRequirements(path, typeParams) {\n  const type = getFlowTypeWithResolvedTypes(path, typeParams);\n  type.required = !path.parentPath.node.optional;\n  return type;\n}\n\nfunction handleKeysHelper(path) {\n  let value = path.get('typeParameters', 'params', 0);\n\n  if (_astTypes.namedTypes.TypeofTypeAnnotation.check(value.node)) {\n    value = value.get('argument', 'id');\n  } else if (!_astTypes.namedTypes.ObjectTypeAnnotation.check(value.node)) {\n    value = value.get('id');\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(value);\n\n  if (resolvedPath && (_astTypes.namedTypes.ObjectExpression.check(resolvedPath.node) || _astTypes.namedTypes.ObjectTypeAnnotation.check(resolvedPath.node))) {\n    const keys = (0, _resolveObjectKeysToArray.resolveObjectToNameArray)(resolvedPath, true);\n\n    if (keys) {\n      return {\n        name: 'union',\n        raw: (0, _printValue.default)(path),\n        elements: keys.map(key => ({\n          name: 'literal',\n          value: key\n        }))\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction handleArrayTypeAnnotation(path, typeParams) {\n  return {\n    name: 'Array',\n    elements: [getFlowTypeWithResolvedTypes(path.get('elementType'), typeParams)],\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nfunction handleGenericTypeAnnotation(path, typeParams) {\n  if (path.node.id.name === '$Keys' && path.node.typeParameters) {\n    return handleKeysHelper(path);\n  }\n\n  let type;\n\n  if (_astTypes.namedTypes.QualifiedTypeIdentifier.check(path.node.id)) {\n    const id = path.get('id');\n\n    if (id.node.qualification.name === 'React') {\n      type = {\n        name: `${id.node.qualification.name}${id.node.id.name}`,\n        raw: (0, _printValue.default)(id)\n      };\n    } else {\n      type = {\n        name: (0, _printValue.default)(id).replace(/<.*>$/, '')\n      };\n    }\n  } else {\n    type = {\n      name: path.node.id.name\n    };\n  }\n\n  const resolvedPath = typeParams && typeParams[type.name] || (0, _resolveToValue.default)(path.get('id'));\n\n  if (path.node.typeParameters && resolvedPath.node.typeParameters) {\n    typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), path.get('typeParameters'), typeParams);\n  }\n\n  if (typeParams && typeParams[type.name] && typeParams[type.name].value.type === _astTypes.namedTypes.GenericTypeAnnotation.name) {\n    return type;\n  }\n\n  if (typeParams && typeParams[type.name]) {\n    type = getFlowTypeWithResolvedTypes(resolvedPath, typeParams);\n  }\n\n  if (resolvedPath && resolvedPath.node.right) {\n    type = getFlowTypeWithResolvedTypes(resolvedPath.get('right'), typeParams);\n  } else if (path.node.typeParameters) {\n    const params = path.get('typeParameters').get('params');\n    type = { ...type,\n      elements: params.map(param => getFlowTypeWithResolvedTypes(param, typeParams)),\n      raw: (0, _printValue.default)(path)\n    };\n  }\n\n  return type;\n}\n\nfunction handleObjectTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: []\n    }\n  };\n  path.get('callProperties').each(param => {\n    type.signature.constructor = getFlowTypeWithResolvedTypes(param.get('value'), typeParams);\n  });\n  path.get('indexers').each(param => {\n    type.signature.properties.push({\n      key: getFlowTypeWithResolvedTypes(param.get('key'), typeParams),\n      value: getFlowTypeWithRequirements(param.get('value'), typeParams)\n    });\n  });\n  path.get('properties').each(param => {\n    if (_astTypes.namedTypes.ObjectTypeProperty.check(param.node)) {\n      type.signature.properties.push({\n        // For ObjectTypeProperties `getPropertyName` always returns string\n        key: (0, _getPropertyName.default)(param),\n        value: getFlowTypeWithRequirements(param.get('value'), typeParams)\n      });\n    }\n  });\n  return type;\n}\n\nfunction handleInterfaceDeclaration(path) {\n  // Interfaces are handled like references which would be documented separately,\n  // rather than inlined like type aliases.\n  return {\n    name: path.node.id.name\n  };\n}\n\nfunction handleUnionTypeAnnotation(path, typeParams) {\n  return {\n    name: 'union',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getFlowTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleIntersectionTypeAnnotation(path, typeParams) {\n  return {\n    name: 'intersection',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getFlowTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleNullableTypeAnnotation(path, typeParams) {\n  const typeAnnotation = (0, _getTypeAnnotation.default)(path);\n  if (!typeAnnotation) return null;\n  const type = getFlowTypeWithResolvedTypes(typeAnnotation, typeParams);\n  type.nullable = true;\n  return type;\n}\n\nfunction handleFunctionTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'function',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      arguments: [],\n      return: getFlowTypeWithResolvedTypes(path.get('returnType'), typeParams)\n    }\n  };\n  path.get('params').each(param => {\n    const typeAnnotation = (0, _getTypeAnnotation.default)(param);\n    type.signature.arguments.push({\n      name: param.node.name ? param.node.name.name : '',\n      type: typeAnnotation ? getFlowTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined\n    });\n  });\n\n  if (path.node.rest) {\n    const rest = path.get('rest');\n    const typeAnnotation = (0, _getTypeAnnotation.default)(rest);\n    type.signature.arguments.push({\n      name: rest.node.name ? rest.node.name.name : '',\n      type: typeAnnotation ? getFlowTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined,\n      rest: true\n    });\n  }\n\n  return type;\n}\n\nfunction handleTupleTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'tuple',\n    raw: (0, _printValue.default)(path),\n    elements: []\n  };\n  path.get('types').each(param => {\n    type.elements.push(getFlowTypeWithResolvedTypes(param, typeParams));\n  });\n  return type;\n}\n\nfunction handleTypeofTypeAnnotation(path, typeParams) {\n  return getFlowTypeWithResolvedTypes(path.get('argument'), typeParams);\n}\n\nlet visitedTypes = {};\n\nfunction getFlowTypeWithResolvedTypes(path, typeParams) {\n  const node = path.node;\n  let type;\n\n  const isTypeAlias = _astTypes.namedTypes.TypeAlias.check(path.parentPath.node); // When we see a typealias mark it as visited so that the next\n  // call of this function does not run into an endless loop\n\n\n  if (isTypeAlias) {\n    if (visitedTypes[path.parentPath.node.id.name] === true) {\n      // if we are currently visiting this node then just return the name\n      // as we are starting to endless loop\n      return {\n        name: path.parentPath.node.id.name\n      };\n    } else if (typeof visitedTypes[path.parentPath.node.id.name] === 'object') {\n      // if we already resolved the type simple return it\n      return visitedTypes[path.parentPath.node.id.name];\n    } // mark the type as visited\n\n\n    visitedTypes[path.parentPath.node.id.name] = true;\n  }\n\n  if (node.type in flowTypes) {\n    type = {\n      name: flowTypes[node.type]\n    };\n  } else if (node.type in flowLiteralTypes) {\n    type = {\n      name: 'literal',\n      value: node.raw || `${node.value}`\n    };\n  } else if (node.type in namedTypes) {\n    type = namedTypes[node.type](path, typeParams);\n  }\n\n  if (!type) {\n    type = {\n      name: 'unknown'\n    };\n  }\n\n  if (isTypeAlias) {\n    // mark the type as unvisited so that further calls can resolve the type again\n    visitedTypes[path.parentPath.node.id.name] = type;\n  }\n\n  return type;\n}\n/**\n * Tries to identify the flow type by inspecting the path for known\n * flow type names. This method doesn't check whether the found type is actually\n * existing. It simply assumes that a match is always valid.\n *\n * If there is no match, \"unknown\" is returned.\n */\n\n\nfunction getFlowType(path, typeParams) {\n  // Empty visited types before an after run\n  // Before: in case the detection threw and we rerun again\n  // After: cleanup memory after we are done here\n  visitedTypes = {};\n  const type = getFlowTypeWithResolvedTypes(path, typeParams);\n  visitedTypes = {};\n  return type;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getFlowType.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","getFlowType","_astTypes","_getPropertyName","_printValue","_getTypeAnnotation","_resolveToValue","_resolveObjectKeysToArray","_getTypeParameters","flowTypes","AnyTypeAnnotation","BooleanTypeAnnotation","MixedTypeAnnotation","NullLiteralTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","VoidTypeAnnotation","EmptyTypeAnnotation","flowLiteralTypes","BooleanLiteralTypeAnnotation","NumberLiteralTypeAnnotation","StringLiteralTypeAnnotation","namedTypes","ArrayTypeAnnotation","handleArrayTypeAnnotation","GenericTypeAnnotation","handleGenericTypeAnnotation","ObjectTypeAnnotation","handleObjectTypeAnnotation","InterfaceDeclaration","handleInterfaceDeclaration","UnionTypeAnnotation","handleUnionTypeAnnotation","NullableTypeAnnotation","handleNullableTypeAnnotation","FunctionTypeAnnotation","handleFunctionTypeAnnotation","IntersectionTypeAnnotation","handleIntersectionTypeAnnotation","TupleTypeAnnotation","handleTupleTypeAnnotation","TypeofTypeAnnotation","handleTypeofTypeAnnotation","getFlowTypeWithRequirements","path","typeParams","type","getFlowTypeWithResolvedTypes","required","parentPath","node","optional","handleKeysHelper","get","check","resolvedPath","ObjectExpression","keys","resolveObjectToNameArray","name","raw","elements","map","key","id","typeParameters","QualifiedTypeIdentifier","qualification","replace","right","params","param","signature","properties","each","constructor","push","ObjectTypeProperty","subType","typeAnnotation","nullable","arguments","return","undefined","rest","visitedTypes","isTypeAlias","TypeAlias"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getFlowType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _getTypeAnnotation = _interopRequireDefault(require(\"../utils/getTypeAnnotation\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveObjectKeysToArray = require(\"../utils/resolveObjectKeysToArray\");\n\nvar _getTypeParameters = _interopRequireDefault(require(\"../utils/getTypeParameters\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nconst flowTypes = {\n  AnyTypeAnnotation: 'any',\n  BooleanTypeAnnotation: 'boolean',\n  MixedTypeAnnotation: 'mixed',\n  NullLiteralTypeAnnotation: 'null',\n  NumberTypeAnnotation: 'number',\n  StringTypeAnnotation: 'string',\n  VoidTypeAnnotation: 'void',\n  EmptyTypeAnnotation: 'empty'\n};\nconst flowLiteralTypes = {\n  BooleanLiteralTypeAnnotation: 1,\n  NumberLiteralTypeAnnotation: 1,\n  StringLiteralTypeAnnotation: 1\n};\nconst namedTypes = {\n  ArrayTypeAnnotation: handleArrayTypeAnnotation,\n  GenericTypeAnnotation: handleGenericTypeAnnotation,\n  ObjectTypeAnnotation: handleObjectTypeAnnotation,\n  InterfaceDeclaration: handleInterfaceDeclaration,\n  UnionTypeAnnotation: handleUnionTypeAnnotation,\n  NullableTypeAnnotation: handleNullableTypeAnnotation,\n  FunctionTypeAnnotation: handleFunctionTypeAnnotation,\n  IntersectionTypeAnnotation: handleIntersectionTypeAnnotation,\n  TupleTypeAnnotation: handleTupleTypeAnnotation,\n  TypeofTypeAnnotation: handleTypeofTypeAnnotation\n};\n\nfunction getFlowTypeWithRequirements(path, typeParams) {\n  const type = getFlowTypeWithResolvedTypes(path, typeParams);\n  type.required = !path.parentPath.node.optional;\n  return type;\n}\n\nfunction handleKeysHelper(path) {\n  let value = path.get('typeParameters', 'params', 0);\n\n  if (_astTypes.namedTypes.TypeofTypeAnnotation.check(value.node)) {\n    value = value.get('argument', 'id');\n  } else if (!_astTypes.namedTypes.ObjectTypeAnnotation.check(value.node)) {\n    value = value.get('id');\n  }\n\n  const resolvedPath = (0, _resolveToValue.default)(value);\n\n  if (resolvedPath && (_astTypes.namedTypes.ObjectExpression.check(resolvedPath.node) || _astTypes.namedTypes.ObjectTypeAnnotation.check(resolvedPath.node))) {\n    const keys = (0, _resolveObjectKeysToArray.resolveObjectToNameArray)(resolvedPath, true);\n\n    if (keys) {\n      return {\n        name: 'union',\n        raw: (0, _printValue.default)(path),\n        elements: keys.map(key => ({\n          name: 'literal',\n          value: key\n        }))\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction handleArrayTypeAnnotation(path, typeParams) {\n  return {\n    name: 'Array',\n    elements: [getFlowTypeWithResolvedTypes(path.get('elementType'), typeParams)],\n    raw: (0, _printValue.default)(path)\n  };\n}\n\nfunction handleGenericTypeAnnotation(path, typeParams) {\n  if (path.node.id.name === '$Keys' && path.node.typeParameters) {\n    return handleKeysHelper(path);\n  }\n\n  let type;\n\n  if (_astTypes.namedTypes.QualifiedTypeIdentifier.check(path.node.id)) {\n    const id = path.get('id');\n\n    if (id.node.qualification.name === 'React') {\n      type = {\n        name: `${id.node.qualification.name}${id.node.id.name}`,\n        raw: (0, _printValue.default)(id)\n      };\n    } else {\n      type = {\n        name: (0, _printValue.default)(id).replace(/<.*>$/, '')\n      };\n    }\n  } else {\n    type = {\n      name: path.node.id.name\n    };\n  }\n\n  const resolvedPath = typeParams && typeParams[type.name] || (0, _resolveToValue.default)(path.get('id'));\n\n  if (path.node.typeParameters && resolvedPath.node.typeParameters) {\n    typeParams = (0, _getTypeParameters.default)(resolvedPath.get('typeParameters'), path.get('typeParameters'), typeParams);\n  }\n\n  if (typeParams && typeParams[type.name] && typeParams[type.name].value.type === _astTypes.namedTypes.GenericTypeAnnotation.name) {\n    return type;\n  }\n\n  if (typeParams && typeParams[type.name]) {\n    type = getFlowTypeWithResolvedTypes(resolvedPath, typeParams);\n  }\n\n  if (resolvedPath && resolvedPath.node.right) {\n    type = getFlowTypeWithResolvedTypes(resolvedPath.get('right'), typeParams);\n  } else if (path.node.typeParameters) {\n    const params = path.get('typeParameters').get('params');\n    type = { ...type,\n      elements: params.map(param => getFlowTypeWithResolvedTypes(param, typeParams)),\n      raw: (0, _printValue.default)(path)\n    };\n  }\n\n  return type;\n}\n\nfunction handleObjectTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'object',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      properties: []\n    }\n  };\n  path.get('callProperties').each(param => {\n    type.signature.constructor = getFlowTypeWithResolvedTypes(param.get('value'), typeParams);\n  });\n  path.get('indexers').each(param => {\n    type.signature.properties.push({\n      key: getFlowTypeWithResolvedTypes(param.get('key'), typeParams),\n      value: getFlowTypeWithRequirements(param.get('value'), typeParams)\n    });\n  });\n  path.get('properties').each(param => {\n    if (_astTypes.namedTypes.ObjectTypeProperty.check(param.node)) {\n      type.signature.properties.push({\n        // For ObjectTypeProperties `getPropertyName` always returns string\n        key: (0, _getPropertyName.default)(param),\n        value: getFlowTypeWithRequirements(param.get('value'), typeParams)\n      });\n    }\n  });\n  return type;\n}\n\nfunction handleInterfaceDeclaration(path) {\n  // Interfaces are handled like references which would be documented separately,\n  // rather than inlined like type aliases.\n  return {\n    name: path.node.id.name\n  };\n}\n\nfunction handleUnionTypeAnnotation(path, typeParams) {\n  return {\n    name: 'union',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getFlowTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleIntersectionTypeAnnotation(path, typeParams) {\n  return {\n    name: 'intersection',\n    raw: (0, _printValue.default)(path),\n    elements: path.get('types').map(subType => getFlowTypeWithResolvedTypes(subType, typeParams))\n  };\n}\n\nfunction handleNullableTypeAnnotation(path, typeParams) {\n  const typeAnnotation = (0, _getTypeAnnotation.default)(path);\n  if (!typeAnnotation) return null;\n  const type = getFlowTypeWithResolvedTypes(typeAnnotation, typeParams);\n  type.nullable = true;\n  return type;\n}\n\nfunction handleFunctionTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'signature',\n    type: 'function',\n    raw: (0, _printValue.default)(path),\n    signature: {\n      arguments: [],\n      return: getFlowTypeWithResolvedTypes(path.get('returnType'), typeParams)\n    }\n  };\n  path.get('params').each(param => {\n    const typeAnnotation = (0, _getTypeAnnotation.default)(param);\n    type.signature.arguments.push({\n      name: param.node.name ? param.node.name.name : '',\n      type: typeAnnotation ? getFlowTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined\n    });\n  });\n\n  if (path.node.rest) {\n    const rest = path.get('rest');\n    const typeAnnotation = (0, _getTypeAnnotation.default)(rest);\n    type.signature.arguments.push({\n      name: rest.node.name ? rest.node.name.name : '',\n      type: typeAnnotation ? getFlowTypeWithResolvedTypes(typeAnnotation, typeParams) : undefined,\n      rest: true\n    });\n  }\n\n  return type;\n}\n\nfunction handleTupleTypeAnnotation(path, typeParams) {\n  const type = {\n    name: 'tuple',\n    raw: (0, _printValue.default)(path),\n    elements: []\n  };\n  path.get('types').each(param => {\n    type.elements.push(getFlowTypeWithResolvedTypes(param, typeParams));\n  });\n  return type;\n}\n\nfunction handleTypeofTypeAnnotation(path, typeParams) {\n  return getFlowTypeWithResolvedTypes(path.get('argument'), typeParams);\n}\n\nlet visitedTypes = {};\n\nfunction getFlowTypeWithResolvedTypes(path, typeParams) {\n  const node = path.node;\n  let type;\n\n  const isTypeAlias = _astTypes.namedTypes.TypeAlias.check(path.parentPath.node); // When we see a typealias mark it as visited so that the next\n  // call of this function does not run into an endless loop\n\n\n  if (isTypeAlias) {\n    if (visitedTypes[path.parentPath.node.id.name] === true) {\n      // if we are currently visiting this node then just return the name\n      // as we are starting to endless loop\n      return {\n        name: path.parentPath.node.id.name\n      };\n    } else if (typeof visitedTypes[path.parentPath.node.id.name] === 'object') {\n      // if we already resolved the type simple return it\n      return visitedTypes[path.parentPath.node.id.name];\n    } // mark the type as visited\n\n\n    visitedTypes[path.parentPath.node.id.name] = true;\n  }\n\n  if (node.type in flowTypes) {\n    type = {\n      name: flowTypes[node.type]\n    };\n  } else if (node.type in flowLiteralTypes) {\n    type = {\n      name: 'literal',\n      value: node.raw || `${node.value}`\n    };\n  } else if (node.type in namedTypes) {\n    type = namedTypes[node.type](path, typeParams);\n  }\n\n  if (!type) {\n    type = {\n      name: 'unknown'\n    };\n  }\n\n  if (isTypeAlias) {\n    // mark the type as unvisited so that further calls can resolve the type again\n    visitedTypes[path.parentPath.node.id.name] = type;\n  }\n\n  return type;\n}\n/**\n * Tries to identify the flow type by inspecting the path for known\n * flow type names. This method doesn't check whether the found type is actually\n * existing. It simply assumes that a match is always valid.\n *\n * If there is no match, \"unknown\" is returned.\n */\n\n\nfunction getFlowType(path, typeParams) {\n  // Empty visited types before an after run\n  // Before: in case the detection threw and we rerun again\n  // After: cleanup memory after we are done here\n  visitedTypes = {};\n  const type = getFlowTypeWithResolvedTypes(path, typeParams);\n  visitedTypes = {};\n  return type;\n}"]},"metadata":{},"sourceType":"script"}