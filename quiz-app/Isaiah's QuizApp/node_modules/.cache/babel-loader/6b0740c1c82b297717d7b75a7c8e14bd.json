{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getPropType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _docblock = require(\"../utils/docblock\");\n\nvar _getMembers = _interopRequireDefault(require(\"./getMembers\"));\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _isRequiredPropType = _interopRequireDefault(require(\"../utils/isRequiredPropType\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\nvar _resolveObjectKeysToArray = _interopRequireDefault(require(\"./resolveObjectKeysToArray\"));\n\nvar _resolveObjectValuesToArray = _interopRequireDefault(require(\"./resolveObjectValuesToArray\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/*eslint no-use-before-define: 0*/\n\n\nfunction getEnumValues(path) {\n  const values = [];\n  path.get('elements').each(function (elementPath) {\n    if (_astTypes.namedTypes.SpreadElement.check(elementPath.node)) {\n      const value = (0, _resolveToValue.default)(elementPath.get('argument'));\n\n      if (_astTypes.namedTypes.ArrayExpression.check(value.node)) {\n        // if the SpreadElement resolved to an Array, add all their elements too\n        return values.push(...getEnumValues(value));\n      } else {\n        // otherwise we'll just print the SpreadElement itself\n        return values.push({\n          value: (0, _printValue.default)(elementPath),\n          computed: !_astTypes.namedTypes.Literal.check(elementPath.node)\n        });\n      }\n    } // try to resolve the array element to it's value\n\n\n    const value = (0, _resolveToValue.default)(elementPath);\n    return values.push({\n      value: (0, _printValue.default)(value),\n      computed: !_astTypes.namedTypes.Literal.check(value.node)\n    });\n  });\n  return values;\n}\n\nfunction getPropTypeOneOf(argumentPath) {\n  const type = {\n    name: 'enum'\n  };\n  let value = (0, _resolveToValue.default)(argumentPath);\n\n  if (!_astTypes.namedTypes.ArrayExpression.check(value.node)) {\n    value = (0, _resolveObjectKeysToArray.default)(value) || (0, _resolveObjectValuesToArray.default)(value);\n\n    if (value) {\n      type.value = getEnumValues(value);\n    } else {\n      // could not easily resolve to an Array, let's print the original value\n      type.computed = true;\n      type.value = (0, _printValue.default)(argumentPath);\n    }\n  } else {\n    type.value = getEnumValues(value);\n  }\n\n  return type;\n}\n\nfunction getPropTypeOneOfType(argumentPath) {\n  const type = {\n    name: 'union'\n  };\n\n  if (!_astTypes.namedTypes.ArrayExpression.check(argumentPath.node)) {\n    type.computed = true;\n    type.value = (0, _printValue.default)(argumentPath);\n  } else {\n    type.value = argumentPath.get('elements').map(function (itemPath) {\n      const descriptor = getPropType(itemPath);\n      const docs = (0, _docblock.getDocblock)(itemPath);\n\n      if (docs) {\n        descriptor.description = docs;\n      }\n\n      return descriptor;\n    });\n  }\n\n  return type;\n}\n\nfunction getPropTypeArrayOf(argumentPath) {\n  const type = {\n    name: 'arrayOf'\n  };\n  const docs = (0, _docblock.getDocblock)(argumentPath);\n\n  if (docs) {\n    type.description = docs;\n  }\n\n  const subType = getPropType(argumentPath);\n\n  if (subType.name === 'unknown') {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  } else {\n    type.value = subType;\n  }\n\n  return type;\n}\n\nfunction getPropTypeObjectOf(argumentPath) {\n  const type = {\n    name: 'objectOf'\n  };\n  const docs = (0, _docblock.getDocblock)(argumentPath);\n\n  if (docs) {\n    type.description = docs;\n  }\n\n  const subType = getPropType(argumentPath);\n\n  if (subType.name === 'unknown') {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  } else {\n    type.value = subType;\n  }\n\n  return type;\n}\n/**\n * Handles shape and exact prop types\n */\n\n\nfunction getPropTypeShapish(name, argumentPath) {\n  const type = {\n    name\n  };\n\n  if (!_astTypes.namedTypes.ObjectExpression.check(argumentPath.node)) {\n    argumentPath = (0, _resolveToValue.default)(argumentPath);\n  }\n\n  if (_astTypes.namedTypes.ObjectExpression.check(argumentPath.node)) {\n    const value = {};\n    argumentPath.get('properties').each(function (propertyPath) {\n      if (propertyPath.get('type').value === _astTypes.namedTypes.SpreadElement.name) {\n        // It is impossible to resolve a name for a spread element\n        return;\n      }\n\n      const propertyName = (0, _getPropertyName.default)(propertyPath);\n      if (!propertyName) return;\n      const descriptor = getPropType(propertyPath.get('value'));\n      const docs = (0, _docblock.getDocblock)(propertyPath);\n\n      if (docs) {\n        descriptor.description = docs;\n      }\n\n      descriptor.required = (0, _isRequiredPropType.default)(propertyPath.get('value'));\n      value[propertyName] = descriptor;\n    });\n    type.value = value;\n  }\n\n  if (!type.value) {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  }\n\n  return type;\n}\n\nfunction getPropTypeInstanceOf(argumentPath) {\n  return {\n    name: 'instanceOf',\n    value: (0, _printValue.default)(argumentPath)\n  };\n}\n\nconst simplePropTypes = ['array', 'bool', 'func', 'number', 'object', 'string', 'any', 'element', 'node', 'symbol', 'elementType'];\nconst propTypes = new Map([['oneOf', getPropTypeOneOf], ['oneOfType', getPropTypeOneOfType], ['instanceOf', getPropTypeInstanceOf], ['arrayOf', getPropTypeArrayOf], ['objectOf', getPropTypeObjectOf], ['shape', getPropTypeShapish.bind(null, 'shape')], ['exact', getPropTypeShapish.bind(null, 'exact')]]);\n/**\n * Tries to identify the prop type by inspecting the path for known\n * prop type names. This method doesn't check whether the found type is actually\n * from React.PropTypes. It simply assumes that a match has the same meaning\n * as the React.PropTypes one.\n *\n * If there is no match, \"custom\" is returned.\n */\n\nfunction getPropType(path) {\n  let descriptor;\n  (0, _getMembers.default)(path, true).some(member => {\n    const node = member.path.node;\n    let name;\n\n    if (_astTypes.namedTypes.Literal.check(node)) {\n      name = node.value;\n    } else if (_astTypes.namedTypes.Identifier.check(node) && !member.computed) {\n      name = node.name;\n    }\n\n    if (name) {\n      if (simplePropTypes.includes(name)) {\n        descriptor = {\n          name\n        };\n        return true;\n      } else if (propTypes.has(name) && member.argumentsPath) {\n        // $FlowIssue\n        descriptor = propTypes.get(name)(member.argumentsPath.get(0));\n        return true;\n      }\n    }\n  });\n\n  if (!descriptor) {\n    const node = path.node;\n\n    if (_astTypes.namedTypes.Identifier.check(node) && simplePropTypes.includes(node.name)) {\n      descriptor = {\n        name: node.name\n      };\n    } else if (_astTypes.namedTypes.CallExpression.check(node) && _astTypes.namedTypes.Identifier.check(node.callee) && propTypes.has(node.callee.name)) {\n      // $FlowIssue\n      descriptor = propTypes.get(node.callee.name)(path.get('arguments', 0));\n    } else {\n      descriptor = {\n        name: 'custom',\n        raw: (0, _printValue.default)(path)\n      };\n    }\n  } // $FlowIssue\n\n\n  return descriptor;\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/utils/getPropType.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","getPropType","_astTypes","_docblock","_getMembers","_getPropertyName","_isRequiredPropType","_printValue","_resolveToValue","_resolveObjectKeysToArray","_resolveObjectValuesToArray","getEnumValues","path","values","get","each","elementPath","namedTypes","SpreadElement","check","node","ArrayExpression","push","computed","Literal","getPropTypeOneOf","argumentPath","type","name","getPropTypeOneOfType","map","itemPath","descriptor","docs","getDocblock","description","getPropTypeArrayOf","subType","getPropTypeObjectOf","getPropTypeShapish","ObjectExpression","propertyPath","propertyName","required","getPropTypeInstanceOf","simplePropTypes","propTypes","Map","bind","some","member","Identifier","includes","has","argumentsPath","CallExpression","callee","raw"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getPropType;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _docblock = require(\"../utils/docblock\");\n\nvar _getMembers = _interopRequireDefault(require(\"./getMembers\"));\n\nvar _getPropertyName = _interopRequireDefault(require(\"./getPropertyName\"));\n\nvar _isRequiredPropType = _interopRequireDefault(require(\"../utils/isRequiredPropType\"));\n\nvar _printValue = _interopRequireDefault(require(\"./printValue\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"./resolveToValue\"));\n\nvar _resolveObjectKeysToArray = _interopRequireDefault(require(\"./resolveObjectKeysToArray\"));\n\nvar _resolveObjectValuesToArray = _interopRequireDefault(require(\"./resolveObjectValuesToArray\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/*eslint no-use-before-define: 0*/\nfunction getEnumValues(path) {\n  const values = [];\n  path.get('elements').each(function (elementPath) {\n    if (_astTypes.namedTypes.SpreadElement.check(elementPath.node)) {\n      const value = (0, _resolveToValue.default)(elementPath.get('argument'));\n\n      if (_astTypes.namedTypes.ArrayExpression.check(value.node)) {\n        // if the SpreadElement resolved to an Array, add all their elements too\n        return values.push(...getEnumValues(value));\n      } else {\n        // otherwise we'll just print the SpreadElement itself\n        return values.push({\n          value: (0, _printValue.default)(elementPath),\n          computed: !_astTypes.namedTypes.Literal.check(elementPath.node)\n        });\n      }\n    } // try to resolve the array element to it's value\n\n\n    const value = (0, _resolveToValue.default)(elementPath);\n    return values.push({\n      value: (0, _printValue.default)(value),\n      computed: !_astTypes.namedTypes.Literal.check(value.node)\n    });\n  });\n  return values;\n}\n\nfunction getPropTypeOneOf(argumentPath) {\n  const type = {\n    name: 'enum'\n  };\n  let value = (0, _resolveToValue.default)(argumentPath);\n\n  if (!_astTypes.namedTypes.ArrayExpression.check(value.node)) {\n    value = (0, _resolveObjectKeysToArray.default)(value) || (0, _resolveObjectValuesToArray.default)(value);\n\n    if (value) {\n      type.value = getEnumValues(value);\n    } else {\n      // could not easily resolve to an Array, let's print the original value\n      type.computed = true;\n      type.value = (0, _printValue.default)(argumentPath);\n    }\n  } else {\n    type.value = getEnumValues(value);\n  }\n\n  return type;\n}\n\nfunction getPropTypeOneOfType(argumentPath) {\n  const type = {\n    name: 'union'\n  };\n\n  if (!_astTypes.namedTypes.ArrayExpression.check(argumentPath.node)) {\n    type.computed = true;\n    type.value = (0, _printValue.default)(argumentPath);\n  } else {\n    type.value = argumentPath.get('elements').map(function (itemPath) {\n      const descriptor = getPropType(itemPath);\n      const docs = (0, _docblock.getDocblock)(itemPath);\n\n      if (docs) {\n        descriptor.description = docs;\n      }\n\n      return descriptor;\n    });\n  }\n\n  return type;\n}\n\nfunction getPropTypeArrayOf(argumentPath) {\n  const type = {\n    name: 'arrayOf'\n  };\n  const docs = (0, _docblock.getDocblock)(argumentPath);\n\n  if (docs) {\n    type.description = docs;\n  }\n\n  const subType = getPropType(argumentPath);\n\n  if (subType.name === 'unknown') {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  } else {\n    type.value = subType;\n  }\n\n  return type;\n}\n\nfunction getPropTypeObjectOf(argumentPath) {\n  const type = {\n    name: 'objectOf'\n  };\n  const docs = (0, _docblock.getDocblock)(argumentPath);\n\n  if (docs) {\n    type.description = docs;\n  }\n\n  const subType = getPropType(argumentPath);\n\n  if (subType.name === 'unknown') {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  } else {\n    type.value = subType;\n  }\n\n  return type;\n}\n/**\n * Handles shape and exact prop types\n */\n\n\nfunction getPropTypeShapish(name, argumentPath) {\n  const type = {\n    name\n  };\n\n  if (!_astTypes.namedTypes.ObjectExpression.check(argumentPath.node)) {\n    argumentPath = (0, _resolveToValue.default)(argumentPath);\n  }\n\n  if (_astTypes.namedTypes.ObjectExpression.check(argumentPath.node)) {\n    const value = {};\n    argumentPath.get('properties').each(function (propertyPath) {\n      if (propertyPath.get('type').value === _astTypes.namedTypes.SpreadElement.name) {\n        // It is impossible to resolve a name for a spread element\n        return;\n      }\n\n      const propertyName = (0, _getPropertyName.default)(propertyPath);\n      if (!propertyName) return;\n      const descriptor = getPropType(propertyPath.get('value'));\n      const docs = (0, _docblock.getDocblock)(propertyPath);\n\n      if (docs) {\n        descriptor.description = docs;\n      }\n\n      descriptor.required = (0, _isRequiredPropType.default)(propertyPath.get('value'));\n      value[propertyName] = descriptor;\n    });\n    type.value = value;\n  }\n\n  if (!type.value) {\n    type.value = (0, _printValue.default)(argumentPath);\n    type.computed = true;\n  }\n\n  return type;\n}\n\nfunction getPropTypeInstanceOf(argumentPath) {\n  return {\n    name: 'instanceOf',\n    value: (0, _printValue.default)(argumentPath)\n  };\n}\n\nconst simplePropTypes = ['array', 'bool', 'func', 'number', 'object', 'string', 'any', 'element', 'node', 'symbol', 'elementType'];\nconst propTypes = new Map([['oneOf', getPropTypeOneOf], ['oneOfType', getPropTypeOneOfType], ['instanceOf', getPropTypeInstanceOf], ['arrayOf', getPropTypeArrayOf], ['objectOf', getPropTypeObjectOf], ['shape', getPropTypeShapish.bind(null, 'shape')], ['exact', getPropTypeShapish.bind(null, 'exact')]]);\n/**\n * Tries to identify the prop type by inspecting the path for known\n * prop type names. This method doesn't check whether the found type is actually\n * from React.PropTypes. It simply assumes that a match has the same meaning\n * as the React.PropTypes one.\n *\n * If there is no match, \"custom\" is returned.\n */\n\nfunction getPropType(path) {\n  let descriptor;\n  (0, _getMembers.default)(path, true).some(member => {\n    const node = member.path.node;\n    let name;\n\n    if (_astTypes.namedTypes.Literal.check(node)) {\n      name = node.value;\n    } else if (_astTypes.namedTypes.Identifier.check(node) && !member.computed) {\n      name = node.name;\n    }\n\n    if (name) {\n      if (simplePropTypes.includes(name)) {\n        descriptor = {\n          name\n        };\n        return true;\n      } else if (propTypes.has(name) && member.argumentsPath) {\n        // $FlowIssue\n        descriptor = propTypes.get(name)(member.argumentsPath.get(0));\n        return true;\n      }\n    }\n  });\n\n  if (!descriptor) {\n    const node = path.node;\n\n    if (_astTypes.namedTypes.Identifier.check(node) && simplePropTypes.includes(node.name)) {\n      descriptor = {\n        name: node.name\n      };\n    } else if (_astTypes.namedTypes.CallExpression.check(node) && _astTypes.namedTypes.Identifier.check(node.callee) && propTypes.has(node.callee.name)) {\n      // $FlowIssue\n      descriptor = propTypes.get(node.callee.name)(path.get('arguments', 0));\n    } else {\n      descriptor = {\n        name: 'custom',\n        raw: (0, _printValue.default)(path)\n      };\n    }\n  } // $FlowIssue\n\n\n  return descriptor;\n}"]},"metadata":{},"sourceType":"script"}