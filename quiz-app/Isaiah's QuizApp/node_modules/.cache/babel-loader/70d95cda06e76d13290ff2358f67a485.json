{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defaultPropsHandler;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"../utils/getPropertyName\"));\n\nvar _getMemberValuePath = _interopRequireDefault(require(\"../utils/getMemberValuePath\"));\n\nvar _printValue = _interopRequireDefault(require(\"../utils/printValue\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveFunctionDefinitionToReturnValue = _interopRequireDefault(require(\"../utils/resolveFunctionDefinitionToReturnValue\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"../utils/isReactComponentClass\"));\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"../utils/isReactForwardRefCall\"));\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nfunction getDefaultValue(path) {\n  let node = path.node;\n  let defaultValue;\n\n  if (_astTypes.namedTypes.Literal.check(node)) {\n    defaultValue = node.raw;\n  } else {\n    if (_astTypes.namedTypes.AssignmentPattern.check(path.node)) {\n      path = (0, _resolveToValue.default)(path.get('right'));\n    } else {\n      path = (0, _resolveToValue.default)(path);\n    }\n\n    if (_astTypes.namedTypes.ImportDeclaration.check(path.node)) {\n      defaultValue = node.name;\n    } else {\n      node = path.node;\n      defaultValue = (0, _printValue.default)(path);\n    }\n  }\n\n  if (typeof defaultValue !== 'undefined') {\n    return {\n      value: defaultValue,\n      computed: _astTypes.namedTypes.CallExpression.check(node) || _astTypes.namedTypes.MemberExpression.check(node) || _astTypes.namedTypes.Identifier.check(node)\n    };\n  }\n\n  return null;\n}\n\nfunction getStatelessPropsPath(componentDefinition) {\n  const value = (0, _resolveToValue.default)(componentDefinition);\n\n  if ((0, _isReactForwardRefCall.default)(value)) {\n    const inner = (0, _resolveToValue.default)(value.get('arguments', 0));\n    return inner.get('params', 0);\n  }\n\n  return value.get('params', 0);\n}\n\nfunction getDefaultPropsPath(componentDefinition) {\n  let defaultPropsPath = (0, _getMemberValuePath.default)(componentDefinition, 'defaultProps');\n\n  if (!defaultPropsPath) {\n    return null;\n  }\n\n  defaultPropsPath = (0, _resolveToValue.default)(defaultPropsPath);\n\n  if (!defaultPropsPath) {\n    return null;\n  }\n\n  if (_astTypes.namedTypes.FunctionExpression.check(defaultPropsPath.node)) {\n    // Find the value that is returned from the function and process it if it is\n    // an object literal.\n    const returnValue = (0, _resolveFunctionDefinitionToReturnValue.default)(defaultPropsPath);\n\n    if (returnValue && _astTypes.namedTypes.ObjectExpression.check(returnValue.node)) {\n      defaultPropsPath = returnValue;\n    }\n  }\n\n  return defaultPropsPath;\n}\n\nfunction getDefaultValuesFromProps(properties, documentation, isStateless) {\n  properties // Don't evaluate property if component is functional and the node is not an AssignmentPattern\n  .filter(propertyPath => !isStateless || _astTypes.namedTypes.AssignmentPattern.check(propertyPath.get('value').node)).forEach(propertyPath => {\n    if (_astTypes.namedTypes.Property.check(propertyPath.node)) {\n      const propName = (0, _getPropertyName.default)(propertyPath);\n      if (!propName) return;\n      const propDescriptor = documentation.getPropDescriptor(propName);\n      const defaultValue = getDefaultValue(isStateless ? propertyPath.get('value', 'right') : propertyPath.get('value'));\n\n      if (defaultValue) {\n        propDescriptor.defaultValue = defaultValue;\n      }\n    } else if (_astTypes.namedTypes.SpreadElement.check(propertyPath.node)) {\n      const resolvedValuePath = (0, _resolveToValue.default)(propertyPath.get('argument'));\n\n      if (_astTypes.namedTypes.ObjectExpression.check(resolvedValuePath.node)) {\n        getDefaultValuesFromProps(resolvedValuePath.get('properties'), documentation, isStateless);\n      }\n    }\n  });\n}\n\nfunction defaultPropsHandler(documentation, componentDefinition) {\n  let statelessProps = null;\n  const defaultPropsPath = getDefaultPropsPath(componentDefinition);\n  /**\n   * function, lazy, memo, forwardRef etc components can resolve default props as well\n   */\n\n  if (!(0, _isReactComponentClass.default)(componentDefinition)) {\n    statelessProps = getStatelessPropsPath(componentDefinition);\n  } // Do both statelessProps and defaultProps if both are available so defaultProps can override\n\n\n  if (statelessProps && _astTypes.namedTypes.ObjectPattern.check(statelessProps.node)) {\n    getDefaultValuesFromProps(statelessProps.get('properties'), documentation, true);\n  }\n\n  if (defaultPropsPath && _astTypes.namedTypes.ObjectExpression.check(defaultPropsPath.node)) {\n    getDefaultValuesFromProps(defaultPropsPath.get('properties'), documentation, false);\n  }\n}","map":{"version":3,"sources":["/Users/idesantis/Documents/GitHub/cis413-submissions-group1/ProjectOne/Isaiah-scratch/quiz-app/Isaiah's QuizApp/node_modules/react-docgen/dist/handlers/defaultPropsHandler.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","defaultPropsHandler","_astTypes","_getPropertyName","_getMemberValuePath","_printValue","_resolveToValue","_resolveFunctionDefinitionToReturnValue","_isReactComponentClass","_isReactForwardRefCall","getDefaultValue","path","node","defaultValue","namedTypes","Literal","check","raw","AssignmentPattern","get","ImportDeclaration","name","computed","CallExpression","MemberExpression","Identifier","getStatelessPropsPath","componentDefinition","inner","getDefaultPropsPath","defaultPropsPath","FunctionExpression","returnValue","ObjectExpression","getDefaultValuesFromProps","properties","documentation","isStateless","filter","propertyPath","forEach","Property","propName","propDescriptor","getPropDescriptor","SpreadElement","resolvedValuePath","statelessProps","ObjectPattern"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = defaultPropsHandler;\n\nvar _astTypes = require(\"ast-types\");\n\nvar _getPropertyName = _interopRequireDefault(require(\"../utils/getPropertyName\"));\n\nvar _getMemberValuePath = _interopRequireDefault(require(\"../utils/getMemberValuePath\"));\n\nvar _printValue = _interopRequireDefault(require(\"../utils/printValue\"));\n\nvar _resolveToValue = _interopRequireDefault(require(\"../utils/resolveToValue\"));\n\nvar _resolveFunctionDefinitionToReturnValue = _interopRequireDefault(require(\"../utils/resolveFunctionDefinitionToReturnValue\"));\n\nvar _isReactComponentClass = _interopRequireDefault(require(\"../utils/isReactComponentClass\"));\n\nvar _isReactForwardRefCall = _interopRequireDefault(require(\"../utils/isReactForwardRefCall\"));\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nfunction getDefaultValue(path) {\n  let node = path.node;\n  let defaultValue;\n\n  if (_astTypes.namedTypes.Literal.check(node)) {\n    defaultValue = node.raw;\n  } else {\n    if (_astTypes.namedTypes.AssignmentPattern.check(path.node)) {\n      path = (0, _resolveToValue.default)(path.get('right'));\n    } else {\n      path = (0, _resolveToValue.default)(path);\n    }\n\n    if (_astTypes.namedTypes.ImportDeclaration.check(path.node)) {\n      defaultValue = node.name;\n    } else {\n      node = path.node;\n      defaultValue = (0, _printValue.default)(path);\n    }\n  }\n\n  if (typeof defaultValue !== 'undefined') {\n    return {\n      value: defaultValue,\n      computed: _astTypes.namedTypes.CallExpression.check(node) || _astTypes.namedTypes.MemberExpression.check(node) || _astTypes.namedTypes.Identifier.check(node)\n    };\n  }\n\n  return null;\n}\n\nfunction getStatelessPropsPath(componentDefinition) {\n  const value = (0, _resolveToValue.default)(componentDefinition);\n\n  if ((0, _isReactForwardRefCall.default)(value)) {\n    const inner = (0, _resolveToValue.default)(value.get('arguments', 0));\n    return inner.get('params', 0);\n  }\n\n  return value.get('params', 0);\n}\n\nfunction getDefaultPropsPath(componentDefinition) {\n  let defaultPropsPath = (0, _getMemberValuePath.default)(componentDefinition, 'defaultProps');\n\n  if (!defaultPropsPath) {\n    return null;\n  }\n\n  defaultPropsPath = (0, _resolveToValue.default)(defaultPropsPath);\n\n  if (!defaultPropsPath) {\n    return null;\n  }\n\n  if (_astTypes.namedTypes.FunctionExpression.check(defaultPropsPath.node)) {\n    // Find the value that is returned from the function and process it if it is\n    // an object literal.\n    const returnValue = (0, _resolveFunctionDefinitionToReturnValue.default)(defaultPropsPath);\n\n    if (returnValue && _astTypes.namedTypes.ObjectExpression.check(returnValue.node)) {\n      defaultPropsPath = returnValue;\n    }\n  }\n\n  return defaultPropsPath;\n}\n\nfunction getDefaultValuesFromProps(properties, documentation, isStateless) {\n  properties // Don't evaluate property if component is functional and the node is not an AssignmentPattern\n  .filter(propertyPath => !isStateless || _astTypes.namedTypes.AssignmentPattern.check(propertyPath.get('value').node)).forEach(propertyPath => {\n    if (_astTypes.namedTypes.Property.check(propertyPath.node)) {\n      const propName = (0, _getPropertyName.default)(propertyPath);\n      if (!propName) return;\n      const propDescriptor = documentation.getPropDescriptor(propName);\n      const defaultValue = getDefaultValue(isStateless ? propertyPath.get('value', 'right') : propertyPath.get('value'));\n\n      if (defaultValue) {\n        propDescriptor.defaultValue = defaultValue;\n      }\n    } else if (_astTypes.namedTypes.SpreadElement.check(propertyPath.node)) {\n      const resolvedValuePath = (0, _resolveToValue.default)(propertyPath.get('argument'));\n\n      if (_astTypes.namedTypes.ObjectExpression.check(resolvedValuePath.node)) {\n        getDefaultValuesFromProps(resolvedValuePath.get('properties'), documentation, isStateless);\n      }\n    }\n  });\n}\n\nfunction defaultPropsHandler(documentation, componentDefinition) {\n  let statelessProps = null;\n  const defaultPropsPath = getDefaultPropsPath(componentDefinition);\n  /**\n   * function, lazy, memo, forwardRef etc components can resolve default props as well\n   */\n\n  if (!(0, _isReactComponentClass.default)(componentDefinition)) {\n    statelessProps = getStatelessPropsPath(componentDefinition);\n  } // Do both statelessProps and defaultProps if both are available so defaultProps can override\n\n\n  if (statelessProps && _astTypes.namedTypes.ObjectPattern.check(statelessProps.node)) {\n    getDefaultValuesFromProps(statelessProps.get('properties'), documentation, true);\n  }\n\n  if (defaultPropsPath && _astTypes.namedTypes.ObjectExpression.check(defaultPropsPath.node)) {\n    getDefaultValuesFromProps(defaultPropsPath.get('properties'), documentation, false);\n  }\n}"]},"metadata":{},"sourceType":"script"}